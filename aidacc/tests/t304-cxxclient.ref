// --- Generated by AidaCxxStub ---
#ifndef __CLNT__aidacc_tests_t304_testpass_idl
#define __CLNT__aidacc_tests_t304_testpass_idl

#ifndef __aidacc_tests_t304_testpass_idl_ifx__
#define __aidacc_tests_t304_testpass_idl_ifx__(...) /**/
#endif

#include <aidacc/aida.hh>

namespace MandatoryNamespace {

/// @cond GeneratedEnums
enum class Enum1 : int64_t {
  E1_A = 1,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum1);
inline std::string to_string   (Enum1 ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum1 &ev) { ev = Aida::enum_value_from_string<Enum1> (en); return true; }
/// @endcond

/// @cond GeneratedEnums
enum class Enum1c : int64_t {
  E1C_A = 1,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum1c);
inline std::string to_string   (Enum1c ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum1c &ev) { ev = Aida::enum_value_from_string<Enum1c> (en); return true; }
/// @endcond

/// @cond GeneratedEnums
enum class Enum2 : int64_t {
  E2_A = 1,
  E2_B = 2,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum2);
inline std::string to_string   (Enum2 ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum2 &ev) { ev = Aida::enum_value_from_string<Enum2> (en); return true; }
/// @endcond

/// @cond GeneratedEnums
enum class Enum2c : int64_t {
  E2C_A = 1,
  E2C_B = 2,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum2c);
inline std::string to_string   (Enum2c ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum2c &ev) { ev = Aida::enum_value_from_string<Enum2c> (en); return true; }
/// @endcond

/// @cond GeneratedEnums
enum class Enum3 : int64_t {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum3);
inline std::string to_string   (Enum3 ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum3 &ev) { ev = Aida::enum_value_from_string<Enum3> (en); return true; }
/// @endcond

/// @cond GeneratedEnums
enum class Enum3c : int64_t {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum3c);
inline std::string to_string   (Enum3c ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum3c &ev) { ev = Aida::enum_value_from_string<Enum3c> (en); return true; }
/// @endcond

/// @cond GeneratedEnums
enum class Enum4a : int64_t {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum4a);
inline std::string to_string   (Enum4a ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum4a &ev) { ev = Aida::enum_value_from_string<Enum4a> (en); return true; }
/// @endcond

/// @cond GeneratedEnums
enum class Enum4b : int64_t {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum4b);
inline std::string to_string   (Enum4b ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum4b &ev) { ev = Aida::enum_value_from_string<Enum4b> (en); return true; }
/// @endcond

/// @cond GeneratedEnums
enum class Enum4c : int64_t {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum4c);
inline std::string to_string   (Enum4c ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum4c &ev) { ev = Aida::enum_value_from_string<Enum4c> (en); return true; }
/// @endcond

/// @cond GeneratedEnums
enum class Enum4d : int64_t {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum4d);
inline std::string to_string   (Enum4d ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum4d &ev) { ev = Aida::enum_value_from_string<Enum4d> (en); return true; }
/// @endcond

/// @cond GeneratedEnums
enum class ExtensiveEnum : int64_t {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = (-9223372036854775807 - 1),
  V26 = 9223372036854775807,
  V27 = 9223372036854775807,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 35,
  V36 = 42, // "foo4"
};
AIDA_DEFINE_ENUM_EQUALITY (ExtensiveEnum);
inline std::string to_string   (ExtensiveEnum ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, ExtensiveEnum &ev) { ev = Aida::enum_value_from_string<ExtensiveEnum> (en); return true; }
/// @endcond
} // MandatoryNamespace

namespace InterfaceTests {

/// @cond GeneratedEnums
enum class QuickEnum : int64_t {
  ZERO = 0,
};
AIDA_DEFINE_ENUM_EQUALITY (QuickEnum);
inline std::string to_string   (QuickEnum ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, QuickEnum &ev) { ev = Aida::enum_value_from_string<QuickEnum> (en); return true; }
/// @endcond
} // InterfaceTests

namespace RapicornAidaTest {

/// @cond GeneratedEnums
enum class ClickType : int64_t {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};
AIDA_DEFINE_ENUM_EQUALITY (ClickType);
inline std::string to_string   (ClickType ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, ClickType &ev) { ev = Aida::enum_value_from_string<ClickType> (en); return true; }
/// @endcond

/// @cond GeneratedEnums
enum class MathExpressions : int64_t {
  RESULT_2 = 2,
  RESULT_5 = 5,
  RESULT_8 = 8,
  RESULT_6 = 6,
  RESULT_7 = 7,
  RESULT_16 = 16,
  RESULT_3 = 3,
  RESULT_24 = 24,
  RESULT_13 = 13,
  RESULT_m2 = -2,
  RESULT_77 = 77,
  RESULT_511 = 511,
};
AIDA_DEFINE_ENUM_EQUALITY (MathExpressions);
inline std::string to_string   (MathExpressions ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, MathExpressions &ev) { ev = Aida::enum_value_from_string<MathExpressions> (en); return true; }
/// @endcond
} // RapicornAidaTest

namespace MandatoryNamespace {

class FirstInterfaceHandle : public virtual Aida::RemoteHandle
{
protected:
public:
  virtual /*dtor*/             ~FirstInterfaceHandle () override;
  /*copy*/                      FirstInterfaceHandle (const FirstInterfaceHandle&) = default;
  FirstInterfaceHandle&         operator= (const FirstInterfaceHandle&) = default;
  static FirstInterfaceHandle   __cast__ (const RemoteHandle &smh);
  explicit                      FirstInterfaceHandle ();
  void                          void_func            ();
  __aidacc_tests_t304_testpass_idl_ifx__ ( FirstInterfaceIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    FirstInterfaceHandle (const std::shared_ptr<FirstInterfaceIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef FirstInterfaceHandle FirstInterfaceH; ///< Convenience alias for the IDL type FirstInterface.
typedef ::Aida::ScopedHandle<FirstInterfaceH> FirstInterfaceS;

class XFooRecord
{
public:
  /// @cond GeneratedFields
  bool                          single_bool = 0;
  int                           single_num = 0;
  int64_t                       num64 = 0;
  double                        single_float = 0;
  std::string                   single_string;
  int                           sibling1 = 0;
  int                           sibling2 = 0;
  int                           multi1 = 0;
  int                           multi2 = 0;
  int                           multi3 = 0;
  int                           multi4 = 0;
  ExtensiveEnum                 enum_field = ExtensiveEnum (0);
  Aida::RemoteMember<FirstInterfaceHandle> iface1;
  Aida::RemoteMember<FirstInterfaceHandle> iface2;
  Aida::RemoteMember<FirstInterfaceHandle> iface3;
  Aida::Any                     any1;
  Aida::Any                     any2;
  Aida::Any                     any3;
  /// @endcond
  inline                        XFooRecord () = default;
  inline                        XFooRecord (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace.XFooRecord"; }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const XFooRecord &other) const;
  bool                          operator!=   (const XFooRecord &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<XFooRecord*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};

class XFooSequence : public std::vector<bool>
{
public:
  typedef std::vector<bool> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  inline                        XFooSequence () = default;
  inline                        XFooSequence (const Aida::AnySeq &s);
  explicit                      XFooSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  std::string                   __typename__      () const	{ return "MandatoryNamespace.XFooSequence"; }
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class IntSequence : public std::vector<int>
{
public:
  typedef std::vector<int> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  inline                        IntSequence () = default;
  inline                        IntSequence (const Aida::AnySeq &s);
  explicit                      IntSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  std::string                   __typename__      () const	{ return "MandatoryNamespace.IntSequence"; }
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class FloatSequence : public std::vector<double>
{
public:
  typedef std::vector<double> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  inline                        FloatSequence () = default;
  inline                        FloatSequence (const Aida::AnySeq &s);
  explicit                      FloatSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  std::string                   __typename__      () const	{ return "MandatoryNamespace.FloatSequence"; }
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class StringSequence : public std::vector<std::string>
{
public:
  typedef std::vector<std::string> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  inline                        StringSequence () = default;
  inline                        StringSequence (const Aida::AnySeq &s);
  explicit                      StringSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  std::string                   __typename__      () const	{ return "MandatoryNamespace.StringSequence"; }
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class ExtensiveEnumSequence : public std::vector<ExtensiveEnum>
{
public:
  typedef std::vector<ExtensiveEnum> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  inline                        ExtensiveEnumSequence () = default;
  inline                        ExtensiveEnumSequence (const Aida::AnySeq &s);
  explicit                      ExtensiveEnumSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  std::string                   __typename__      () const	{ return "MandatoryNamespace.ExtensiveEnumSequence"; }
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class RecordSequence : public std::vector<XFooRecord>
{
public:
  typedef std::vector<XFooRecord> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  inline                        RecordSequence () = default;
  inline                        RecordSequence (const Aida::AnySeq &s);
  explicit                      RecordSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  std::string                   __typename__      () const	{ return "MandatoryNamespace.RecordSequence"; }
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class SequenceSequence : public std::vector<IntSequence>
{
public:
  typedef std::vector<IntSequence> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  inline                        SequenceSequence () = default;
  inline                        SequenceSequence (const Aida::AnySeq &s);
  explicit                      SequenceSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  std::string                   __typename__      () const	{ return "MandatoryNamespace.SequenceSequence"; }
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class InterfaceSequence : public std::vector<Aida::RemoteMember<FirstInterfaceHandle>>
{
public:
  typedef std::vector<Aida::RemoteMember<FirstInterfaceHandle>> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  inline                        InterfaceSequence () = default;
  inline                        InterfaceSequence (const Aida::AnySeq &s);
  explicit                      InterfaceSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  std::string                   __typename__      () const	{ return "MandatoryNamespace.InterfaceSequence"; }
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class AnySequence : public std::vector<Aida::Any>
{
public:
  typedef std::vector<Aida::Any> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  inline                        AnySequence () = default;
  inline                        AnySequence (const Aida::AnySeq &s);
  explicit                      AnySequence (std::initializer_list<value_type> il) : Sequence (il) {};
  std::string                   __typename__      () const	{ return "MandatoryNamespace.AnySequence"; }
  static const Aida::StringVector& __typedata__ ();
};

class NestedTypesRec;

class NestedTypesSeq;

class NestedTypesRec
{
public:
  /// @cond GeneratedFields
  XFooRecord                    rec;
  XFooSequence                  seq;
  /// @endcond
  inline                        NestedTypesRec () = default;
  inline                        NestedTypesRec (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace.NestedTypesRec"; }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const NestedTypesRec &other) const;
  bool                          operator!=   (const NestedTypesRec &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<NestedTypesRec*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};

class NestedTypesSeq : public std::vector<NestedTypesRec>
{
public:
  typedef std::vector<NestedTypesRec> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  inline                        NestedTypesSeq () = default;
  inline                        NestedTypesSeq (const Aida::AnySeq &s);
  explicit                      NestedTypesSeq (std::initializer_list<value_type> il) : Sequence (il) {};
  std::string                   __typename__      () const	{ return "MandatoryNamespace.NestedTypesSeq"; }
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class NewRecord
{
public:
  /// @cond GeneratedFields
  int                           i = 0;
  Enum1                         enum1 = Enum1 (0);
  XFooSequence                  xfs;
  NestedTypesRec                ntr;
  /// @endcond
  inline                        NewRecord () = default;
  inline                        NewRecord (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace.NewRecord"; }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const NewRecord &other) const;
  bool                          operator!=   (const NewRecord &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<NewRecord*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};

namespace Inner {

class InnerRecord
{
public:
  /// @cond GeneratedFields
  int                           x = 0;
  int                           y = 0;
  NewRecord                     rec;
  /// @endcond
  inline                        InnerRecord () = default;
  inline                        InnerRecord (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace.Inner.InnerRecord"; }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const InnerRecord &other) const;
  bool                          operator!=   (const InnerRecord &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<InnerRecord*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};
} // Inner

class Refer2Inner
{
public:
  /// @cond GeneratedFields
  Inner::InnerRecord            r;
  /// @endcond
  inline                        Refer2Inner () = default;
  inline                        Refer2Inner (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace.Refer2Inner"; }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const Refer2Inner &other) const;
  bool                          operator!=   (const Refer2Inner &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<Refer2Inner*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};
} // MandatoryNamespace

namespace OtherNamespace {

class SomeRecord
{
public:
  /// @cond GeneratedFields
  MandatoryNamespace::NewRecord r1;
  MandatoryNamespace::NewRecord r2;
  MandatoryNamespace::Inner::InnerRecord r3;
  MandatoryNamespace::Inner::InnerRecord r4;
  /// @endcond
  inline                        SomeRecord () = default;
  inline                        SomeRecord (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  std::string                   __typename__      () const	{ return "OtherNamespace.SomeRecord"; }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const SomeRecord &other) const;
  bool                          operator!=   (const SomeRecord &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<SomeRecord*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};
} // OtherNamespace

namespace Auxdata {

class RecordWithAuxdata
{
public:
  /// @cond GeneratedFields
  bool                          aux_bool = 0;
  int                           aux32 = 0;
  int64_t                       aux64 = 0;
  double                        auxf64 = 0;
  std::string                   aux_str;
  /// @endcond
  inline                        RecordWithAuxdata () = default;
  inline                        RecordWithAuxdata (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  std::string                   __typename__      () const	{ return "Auxdata.RecordWithAuxdata"; }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const RecordWithAuxdata &other) const;
  bool                          operator!=   (const RecordWithAuxdata &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<RecordWithAuxdata*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};
} // Auxdata

namespace InterfaceTests {

class UIWidgetAreaHandle : public virtual Aida::RemoteHandle
{
protected:
public:
  virtual /*dtor*/             ~UIWidgetAreaHandle () override;
  /*copy*/                      UIWidgetAreaHandle (const UIWidgetAreaHandle&) = default;
  UIWidgetAreaHandle&           operator= (const UIWidgetAreaHandle&) = default;
  static UIWidgetAreaHandle     __cast__ (const RemoteHandle &smh);
  explicit                      UIWidgetAreaHandle ();
  bool                          dummy    () const;
  void                          dummy    (bool);
  std::string                   on_click () const;
  void                          on_click (const std::string&);
  double                        simple_method      ();
  double                        single_arg         (int n);
  double                        single_arg2        (int n = 5);
  double                        two_args           (int n,
                                                    double r);
  double                        two_args2          (int n = 6,
                                                    double r = 7.7);
  double                        multi_args         (bool b,
                                                    int64_t n,
                                                    double r,
                                                    int i,
                                                    const std::string &s = "String ding",
                                                    double y = 5);
  double                        self_method        (UIWidgetAreaHandle &ba1,
                                                    UIWidgetAreaHandle &ba2);
  void                          void_method        ();
  std::string                   on_click2out       ();
  void                          on_click2in        (const std::string &command);
  __aidacc_tests_t304_testpass_idl_ifx__ ( UIWidgetAreaIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    UIWidgetAreaHandle (const std::shared_ptr<UIWidgetAreaIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "dummy", &UIWidgetAreaHandle::dummy, &UIWidgetAreaHandle::dummy);
    __visitor_ (*this, "on_click", &UIWidgetAreaHandle::on_click, &UIWidgetAreaHandle::on_click);
  }
};
typedef UIWidgetAreaHandle UIWidgetAreaH; ///< Convenience alias for the IDL type UIWidgetArea.
typedef ::Aida::ScopedHandle<UIWidgetAreaH> UIWidgetAreaS;

class ParentHandle : public virtual Aida::RemoteHandle
{
protected:
public:
  virtual /*dtor*/             ~ParentHandle () override;
  /*copy*/                      ParentHandle (const ParentHandle&) = default;
  ParentHandle&                 operator= (const ParentHandle&) = default;
  static ParentHandle           __cast__ (const RemoteHandle &smh);
  explicit                      ParentHandle ();
  __aidacc_tests_t304_testpass_idl_ifx__ ( ParentIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    ParentHandle (const std::shared_ptr<ParentIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef ParentHandle ParentH; ///< Convenience alias for the IDL type Parent.
typedef ::Aida::ScopedHandle<ParentH> ParentS;

class ChildHandle : public virtual ParentHandle
{
protected:
public:
  virtual /*dtor*/             ~ChildHandle () override;
  /*copy*/                      ChildHandle (const ChildHandle&) = default;
  ChildHandle&                  operator= (const ChildHandle&) = default;
  static ChildHandle            __cast__ (const RemoteHandle &smh);
  explicit                      ChildHandle ();
  __aidacc_tests_t304_testpass_idl_ifx__ ( ChildIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    ChildHandle (const std::shared_ptr<ChildIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->ParentHandle::__accept_accessor__ (__visitor_);
  }
};
typedef ChildHandle ChildH; ///< Convenience alias for the IDL type Child.
typedef ::Aida::ScopedHandle<ChildH> ChildS;

class DescendantHandle : public virtual ChildHandle
{
protected:
public:
  virtual /*dtor*/             ~DescendantHandle () override;
  /*copy*/                      DescendantHandle (const DescendantHandle&) = default;
  DescendantHandle&             operator= (const DescendantHandle&) = default;
  static DescendantHandle       __cast__ (const RemoteHandle &smh);
  explicit                      DescendantHandle ();
  __aidacc_tests_t304_testpass_idl_ifx__ ( DescendantIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    DescendantHandle (const std::shared_ptr<DescendantIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->ChildHandle::__accept_accessor__ (__visitor_);
  }
};
typedef DescendantHandle DescendantH; ///< Convenience alias for the IDL type Descendant.
typedef ::Aida::ScopedHandle<DescendantH> DescendantS;

class GrandChildHandle : public virtual DescendantHandle
{
protected:
public:
  virtual /*dtor*/             ~GrandChildHandle () override;
  /*copy*/                      GrandChildHandle (const GrandChildHandle&) = default;
  GrandChildHandle&             operator= (const GrandChildHandle&) = default;
  static GrandChildHandle       __cast__ (const RemoteHandle &smh);
  explicit                      GrandChildHandle ();
  __aidacc_tests_t304_testpass_idl_ifx__ ( GrandChildIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    GrandChildHandle (const std::shared_ptr<GrandChildIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->DescendantHandle::__accept_accessor__ (__visitor_);
  }
};
typedef GrandChildHandle GrandChildH; ///< Convenience alias for the IDL type GrandChild.
typedef ::Aida::ScopedHandle<GrandChildH> GrandChildS;

class QuickRecord
{
public:
  /// @cond GeneratedFields
  int                           int1 = 0;
  int                           int2 = 0;
  /// @endcond
  inline                        QuickRecord () = default;
  inline                        QuickRecord (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  std::string                   __typename__      () const	{ return "InterfaceTests.QuickRecord"; }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const QuickRecord &other) const;
  bool                          operator!=   (const QuickRecord &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<QuickRecord*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};

class QuickSequence : public std::vector<double>
{
public:
  typedef std::vector<double> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  inline                        QuickSequence () = default;
  inline                        QuickSequence (const Aida::AnySeq &s);
  explicit                      QuickSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  std::string                   __typename__      () const	{ return "InterfaceTests.QuickSequence"; }
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class QuickIfaceHandle : public virtual Aida::RemoteHandle
{
protected:
public:
  virtual /*dtor*/             ~QuickIfaceHandle () override;
  /*copy*/                      QuickIfaceHandle (const QuickIfaceHandle&) = default;
  QuickIfaceHandle&             operator= (const QuickIfaceHandle&) = default;
  static QuickIfaceHandle       __cast__ (const RemoteHandle &smh);
  explicit                      QuickIfaceHandle ();
  void                          simple_function  (int i = 9);
  __aidacc_tests_t304_testpass_idl_ifx__ ( QuickIfaceIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    QuickIfaceHandle (const std::shared_ptr<QuickIfaceIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef QuickIfaceHandle QuickIfaceH; ///< Convenience alias for the IDL type QuickIface.
typedef ::Aida::ScopedHandle<QuickIfaceH> QuickIfaceS;

class MethodTestInterfaceHandle : public virtual Aida::RemoteHandle
{
protected:
public:
  virtual /*dtor*/             ~MethodTestInterfaceHandle () override;
  /*copy*/                      MethodTestInterfaceHandle (const MethodTestInterfaceHandle&) = default;
  MethodTestInterfaceHandle&    operator= (const MethodTestInterfaceHandle&) = default;
  static MethodTestInterfaceHandle __cast__ (const RemoteHandle &smh);
  explicit                      MethodTestInterfaceHandle ();
  void                          method_with_void          ();
  bool                          method_with_bools         (bool input,
                                                           bool optval = 0);
  int                           method_with_ints32        (int input,
                                                           int optval = -2);
  int64_t                       method_with_ints64        (int64_t input,
                                                           int64_t optval = 576460752303423488);
  double                        method_with_floats        (double input,
                                                           double optval = 309.9);
  std::string                   method_with_string        (const std::string &input,
                                                           const std::string &optval = "default");
  QuickEnum                     method_with_enum          (QuickEnum input,
                                                           QuickEnum optval = QuickEnum (0));
  QuickRecord                   method_with_record        (const QuickRecord &input,
                                                           const QuickRecord &optval = QuickRecord());
  QuickSequence                 method_with_sequence      (const QuickSequence &input,
                                                           const QuickSequence &optval = QuickSequence());
  GrandChildHandle              method_with_interface     (GrandChildHandle &input,
                                                           GrandChildHandle &optval);
  Aida::Any                     method_with_anys          (const Aida::Any &input,
                                                           const Aida::Any &optval);
  QuickIfaceHandle              method_with_quickiface    (QuickIfaceHandle &input,
                                                           QuickIfaceHandle &iface0);
  __aidacc_tests_t304_testpass_idl_ifx__ ( MethodTestInterfaceIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    MethodTestInterfaceHandle (const std::shared_ptr<MethodTestInterfaceIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef MethodTestInterfaceHandle MethodTestInterfaceH; ///< Convenience alias for the IDL type MethodTestInterface.
typedef ::Aida::ScopedHandle<MethodTestInterfaceH> MethodTestInterfaceS;

class SignalTestInterfaceHandle : public virtual Aida::RemoteHandle
{
protected:
public:
  virtual /*dtor*/             ~SignalTestInterfaceHandle () override;
  /*copy*/                      SignalTestInterfaceHandle (const SignalTestInterfaceHandle&) = default;
  SignalTestInterfaceHandle&    operator= (const SignalTestInterfaceHandle&) = default;
  static SignalTestInterfaceHandle __cast__ (const RemoteHandle &smh);
  explicit                      SignalTestInterfaceHandle ();
  __aidacc_tests_t304_testpass_idl_ifx__ ( SignalTestInterfaceIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    SignalTestInterfaceHandle (const std::shared_ptr<SignalTestInterfaceIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef SignalTestInterfaceHandle SignalTestInterfaceH; ///< Convenience alias for the IDL type SignalTestInterface.
typedef ::Aida::ScopedHandle<SignalTestInterfaceH> SignalTestInterfaceS;

class ChildInheritingSignalsHandle : public virtual SignalTestInterfaceHandle
{
protected:
public:
  virtual /*dtor*/             ~ChildInheritingSignalsHandle () override;
  /*copy*/                      ChildInheritingSignalsHandle (const ChildInheritingSignalsHandle&) = default;
  ChildInheritingSignalsHandle& operator= (const ChildInheritingSignalsHandle&) = default;
  static ChildInheritingSignalsHandle __cast__ (const RemoteHandle &smh);
  explicit                      ChildInheritingSignalsHandle ();
  __aidacc_tests_t304_testpass_idl_ifx__ ( ChildInheritingSignalsIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    ChildInheritingSignalsHandle (const std::shared_ptr<ChildInheritingSignalsIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->SignalTestInterfaceHandle::__accept_accessor__ (__visitor_);
  }
};
typedef ChildInheritingSignalsHandle ChildInheritingSignalsH; ///< Convenience alias for the IDL type ChildInheritingSignals.
typedef ::Aida::ScopedHandle<ChildInheritingSignalsH> ChildInheritingSignalsS;

class AnotherChildHandle : public virtual SignalTestInterfaceHandle
{
protected:
public:
  virtual /*dtor*/             ~AnotherChildHandle () override;
  /*copy*/                      AnotherChildHandle (const AnotherChildHandle&) = default;
  AnotherChildHandle&           operator= (const AnotherChildHandle&) = default;
  static AnotherChildHandle     __cast__ (const RemoteHandle &smh);
  explicit                      AnotherChildHandle ();
  __aidacc_tests_t304_testpass_idl_ifx__ ( AnotherChildIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    AnotherChildHandle (const std::shared_ptr<AnotherChildIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->SignalTestInterfaceHandle::__accept_accessor__ (__visitor_);
  }
};
typedef AnotherChildHandle AnotherChildH; ///< Convenience alias for the IDL type AnotherChild.
typedef ::Aida::ScopedHandle<AnotherChildH> AnotherChildS;

class PropertyTesterHandle : public virtual Aida::RemoteHandle
{
protected:
public:
  virtual /*dtor*/             ~PropertyTesterHandle () override;
  /*copy*/                      PropertyTesterHandle (const PropertyTesterHandle&) = default;
  PropertyTesterHandle&         operator= (const PropertyTesterHandle&) = default;
  static PropertyTesterHandle   __cast__ (const RemoteHandle &smh);
  explicit                      PropertyTesterHandle ();
  bool                          bool_prop      () const;
  void                          bool_prop      (bool);
  int                           int32_prop     () const;
  void                          int32_prop     (int);
  int64_t                       int64_prop     () const;
  void                          int64_prop     (int64_t);
  double                        float64_prop   () const;
  void                          float64_prop   (double);
  std::string                   string_prop    () const;
  void                          string_prop    (const std::string&);
  QuickEnum                     enum_prop      () const;
  void                          enum_prop      (QuickEnum);
  QuickRecord                   record_prop    () const;
  void                          record_prop    (const QuickRecord&);
  QuickSequence                 sequence_prop  () const;
  void                          sequence_prop  (const QuickSequence&);
  GrandChildHandle              interface_prop () const;
  void                          interface_prop (GrandChildHandle);
  PropertyTesterHandle          self_prop      () const;
  void                          self_prop      (PropertyTesterHandle);
  Aida::Any                     any_prop       () const;
  void                          any_prop       (const Aida::Any&);
  __aidacc_tests_t304_testpass_idl_ifx__ ( PropertyTesterIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    PropertyTesterHandle (const std::shared_ptr<PropertyTesterIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "bool_prop", &PropertyTesterHandle::bool_prop, &PropertyTesterHandle::bool_prop);
    __visitor_ (*this, "int32_prop", &PropertyTesterHandle::int32_prop, &PropertyTesterHandle::int32_prop);
    __visitor_ (*this, "int64_prop", &PropertyTesterHandle::int64_prop, &PropertyTesterHandle::int64_prop);
    __visitor_ (*this, "float64_prop", &PropertyTesterHandle::float64_prop, &PropertyTesterHandle::float64_prop);
    __visitor_ (*this, "string_prop", &PropertyTesterHandle::string_prop, &PropertyTesterHandle::string_prop);
    __visitor_ (*this, "enum_prop", &PropertyTesterHandle::enum_prop, &PropertyTesterHandle::enum_prop);
    __visitor_ (*this, "record_prop", &PropertyTesterHandle::record_prop, &PropertyTesterHandle::record_prop);
    __visitor_ (*this, "sequence_prop", &PropertyTesterHandle::sequence_prop, &PropertyTesterHandle::sequence_prop);
    __visitor_ (*this, "interface_prop", &PropertyTesterHandle::interface_prop, &PropertyTesterHandle::interface_prop);
    __visitor_ (*this, "self_prop", &PropertyTesterHandle::self_prop, &PropertyTesterHandle::self_prop);
    __visitor_ (*this, "any_prop", &PropertyTesterHandle::any_prop, &PropertyTesterHandle::any_prop);
  }
};
typedef PropertyTesterHandle PropertyTesterH; ///< Convenience alias for the IDL type PropertyTester.
typedef ::Aida::ScopedHandle<PropertyTesterH> PropertyTesterS;
} // InterfaceTests

namespace RapicornAidaTest {

class UseIncludesHandle : public virtual IncludeCheck::SomeInterfaceHandle
{
protected:
public:
  virtual /*dtor*/             ~UseIncludesHandle () override;
  /*copy*/                      UseIncludesHandle (const UseIncludesHandle&) = default;
  UseIncludesHandle&            operator= (const UseIncludesHandle&) = default;
  static UseIncludesHandle      __cast__ (const RemoteHandle &smh);
  explicit                      UseIncludesHandle ();
  __aidacc_tests_t304_testpass_idl_ifx__ ( UseIncludesIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    UseIncludesHandle (const std::shared_ptr<UseIncludesIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->IncludeCheck::SomeInterfaceHandle::__accept_accessor__ (__visitor_);
  }
};
typedef UseIncludesHandle UseIncludesH; ///< Convenience alias for the IDL type UseIncludes.
typedef ::Aida::ScopedHandle<UseIncludesH> UseIncludesS;

class ButtonAreaHandle : public virtual Aida::RemoteHandle
{
protected:
public:
  virtual /*dtor*/             ~ButtonAreaHandle () override;
  /*copy*/                      ButtonAreaHandle (const ButtonAreaHandle&) = default;
  ButtonAreaHandle&             operator= (const ButtonAreaHandle&) = default;
  static ButtonAreaHandle       __cast__ (const RemoteHandle &smh);
  explicit                      ButtonAreaHandle ();
  std::string                   on_click   () const;
  void                          on_click   (const std::string&);
  std::string                   on_click2  () const;
  void                          on_click2  (const std::string&);
  std::string                   on_click3  () const;
  void                          on_click3  (const std::string&);
  ClickType                     click_type () const;
  void                          click_type (ClickType);
  __aidacc_tests_t304_testpass_idl_ifx__ ( ButtonAreaIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    ButtonAreaHandle (const std::shared_ptr<ButtonAreaIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "on_click", &ButtonAreaHandle::on_click, &ButtonAreaHandle::on_click);
    __visitor_ (*this, "on_click2", &ButtonAreaHandle::on_click2, &ButtonAreaHandle::on_click2);
    __visitor_ (*this, "on_click3", &ButtonAreaHandle::on_click3, &ButtonAreaHandle::on_click3);
    __visitor_ (*this, "click_type", &ButtonAreaHandle::click_type, &ButtonAreaHandle::click_type);
  }
};
typedef ButtonAreaHandle ButtonAreaH; ///< Convenience alias for the IDL type ButtonArea.
typedef ::Aida::ScopedHandle<ButtonAreaH> ButtonAreaS;

class PureMethodsHandle;

class PureMethodsHandle : public virtual Aida::RemoteHandle
{
protected:
public:
  virtual /*dtor*/             ~PureMethodsHandle () override;
  /*copy*/                      PureMethodsHandle (const PureMethodsHandle&) = default;
  PureMethodsHandle&            operator= (const PureMethodsHandle&) = default;
  static PureMethodsHandle      __cast__ (const RemoteHandle &smh);
  explicit                      PureMethodsHandle ();
  int                           pure_method       (double f);
  __aidacc_tests_t304_testpass_idl_ifx__ ( PureMethodsIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    PureMethodsHandle (const std::shared_ptr<PureMethodsIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef PureMethodsHandle PureMethodsH; ///< Convenience alias for the IDL type PureMethods.
typedef ::Aida::ScopedHandle<PureMethodsH> PureMethodsS;
} // RapicornAidaTest

namespace Other {

class NameTestsHandle : public virtual Aida::RemoteHandle
{
protected:
public:
  virtual /*dtor*/             ~NameTestsHandle () override;
  /*copy*/                      NameTestsHandle (const NameTestsHandle&) = default;
  NameTestsHandle&              operator= (const NameTestsHandle&) = default;
  static NameTestsHandle        __cast__ (const RemoteHandle &smh);
  explicit                      NameTestsHandle ();
  void                          args_from_other_namespace (const InterfaceTests::QuickRecord &qr,
                                                           RapicornAidaTest::ClickType qe,
                                                           const OtherNamespace::SomeRecord &sr);
  __aidacc_tests_t304_testpass_idl_ifx__ ( NameTestsIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    NameTestsHandle (const std::shared_ptr<NameTestsIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef NameTestsHandle NameTestsH; ///< Convenience alias for the IDL type NameTests.
typedef ::Aida::ScopedHandle<NameTestsH> NameTestsS;
} // Other

namespace BseTest {

class CompressorHandle : public virtual Aida::RemoteHandle
{
protected:
public:
  virtual /*dtor*/             ~CompressorHandle () override;
  /*copy*/                      CompressorHandle (const CompressorHandle&) = default;
  CompressorHandle&             operator= (const CompressorHandle&) = default;
  static CompressorHandle       __cast__ (const RemoteHandle &smh);
  explicit                      CompressorHandle ();
  double                        threshold () const;
  void                          threshold (double);
  double                        ratio     () const;
  void                          ratio     (double);
  __aidacc_tests_t304_testpass_idl_ifx__ ( CompressorIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    CompressorHandle (const std::shared_ptr<CompressorIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "threshold", &CompressorHandle::threshold, &CompressorHandle::threshold);
    __visitor_ (*this, "ratio", &CompressorHandle::ratio, &CompressorHandle::ratio);
  }
};
typedef CompressorHandle CompressorH; ///< Convenience alias for the IDL type Compressor.
typedef ::Aida::ScopedHandle<CompressorH> CompressorS;

class RecordForGroups
{
public:
  /// @cond GeneratedFields
  int                           i = 0;
  double                        ratio = 0;
  bool                          ordinary_bool = 0;
  double                        threshold1 = 0;
  double                        threshold2 = 0;
  /// @endcond
  inline                        RecordForGroups () = default;
  inline                        RecordForGroups (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  std::string                   __typename__      () const	{ return "BseTest.RecordForGroups"; }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const RecordForGroups &other) const;
  bool                          operator!=   (const RecordForGroups &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<RecordForGroups*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};

class SoundModuleHandle : public virtual Aida::RemoteHandle
{
protected:
public:
  virtual /*dtor*/             ~SoundModuleHandle () override;
  /*copy*/                      SoundModuleHandle (const SoundModuleHandle&) = default;
  SoundModuleHandle&            operator= (const SoundModuleHandle&) = default;
  static SoundModuleHandle      __cast__ (const RemoteHandle &smh);
  explicit                      SoundModuleHandle ();
  __aidacc_tests_t304_testpass_idl_ifx__ ( SoundModuleIface*  __iface__ () const );
  __aidacc_tests_t304_testpass_idl_ifx__ ( /*conv*/    SoundModuleHandle (const std::shared_ptr<SoundModuleIface>&) );
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
typedef SoundModuleHandle SoundModuleH; ///< Convenience alias for the IDL type SoundModule.
typedef ::Aida::ScopedHandle<SoundModuleH> SoundModuleS;
} // BseTest

namespace MandatoryNamespace {
template<class Visitor> void
XFooRecord::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (single_bool, "single_bool");
  std::forward<Visitor> (_visitor_) (single_num, "single_num");
  std::forward<Visitor> (_visitor_) (num64, "num64");
  std::forward<Visitor> (_visitor_) (single_float, "single_float");
  std::forward<Visitor> (_visitor_) (single_string, "single_string");
  std::forward<Visitor> (_visitor_) (sibling1, "sibling1");
  std::forward<Visitor> (_visitor_) (sibling2, "sibling2");
  std::forward<Visitor> (_visitor_) (multi1, "multi1");
  std::forward<Visitor> (_visitor_) (multi2, "multi2");
  std::forward<Visitor> (_visitor_) (multi3, "multi3");
  std::forward<Visitor> (_visitor_) (multi4, "multi4");
  std::forward<Visitor> (_visitor_) (enum_field, "enum_field");
  std::forward<Visitor> (_visitor_) (iface1, "iface1");
  std::forward<Visitor> (_visitor_) (iface2, "iface2");
  std::forward<Visitor> (_visitor_) (iface3, "iface3");
  std::forward<Visitor> (_visitor_) (any1, "any1");
  std::forward<Visitor> (_visitor_) (any2, "any2");
  std::forward<Visitor> (_visitor_) (any3, "any3");
}
inline
XFooSequence::XFooSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<XFooSequence::value_type>::type >());
}
inline
XFooSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
IntSequence::IntSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<IntSequence::value_type>::type >());
}
inline
IntSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
FloatSequence::FloatSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<FloatSequence::value_type>::type >());
}
inline
FloatSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
StringSequence::StringSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<StringSequence::value_type>::type >());
}
inline
StringSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
ExtensiveEnumSequence::ExtensiveEnumSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<ExtensiveEnumSequence::value_type>::type >());
}
inline
ExtensiveEnumSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
RecordSequence::RecordSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<RecordSequence::value_type>::type >());
}
inline
RecordSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
SequenceSequence::SequenceSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<SequenceSequence::value_type>::type >());
}
inline
SequenceSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
InterfaceSequence::InterfaceSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<InterfaceSequence::value_type>::type >());
}
inline
InterfaceSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
AnySequence::AnySequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<AnySequence::value_type>::type >());
}
template<class Visitor> void
NestedTypesRec::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (rec, "rec");
  std::forward<Visitor> (_visitor_) (seq, "seq");
}
inline
NestedTypesSeq::NestedTypesSeq (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<NestedTypesSeq::value_type>::type >());
}
inline
NestedTypesSeq::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
template<class Visitor> void
NewRecord::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (i, "i");
  std::forward<Visitor> (_visitor_) (enum1, "enum1");
  std::forward<Visitor> (_visitor_) (xfs, "xfs");
  std::forward<Visitor> (_visitor_) (ntr, "ntr");
}

namespace Inner {
template<class Visitor> void
InnerRecord::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (x, "x");
  std::forward<Visitor> (_visitor_) (y, "y");
  std::forward<Visitor> (_visitor_) (rec, "rec");
}
} // Inner
template<class Visitor> void
Refer2Inner::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (r, "r");
}
} // MandatoryNamespace

namespace OtherNamespace {
template<class Visitor> void
SomeRecord::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (r1, "r1");
  std::forward<Visitor> (_visitor_) (r2, "r2");
  std::forward<Visitor> (_visitor_) (r3, "r3");
  std::forward<Visitor> (_visitor_) (r4, "r4");
}
} // OtherNamespace

namespace Auxdata {
template<class Visitor> void
RecordWithAuxdata::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (aux_bool, "aux_bool");
  std::forward<Visitor> (_visitor_) (aux32, "aux32");
  std::forward<Visitor> (_visitor_) (aux64, "aux64");
  std::forward<Visitor> (_visitor_) (auxf64, "auxf64");
  std::forward<Visitor> (_visitor_) (aux_str, "aux_str");
}
} // Auxdata

namespace InterfaceTests {
template<class Visitor> void
QuickRecord::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (int1, "int1");
  std::forward<Visitor> (_visitor_) (int2, "int2");
}
inline
QuickSequence::QuickSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<QuickSequence::value_type>::type >());
}
inline
QuickSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
} // InterfaceTests

namespace BseTest {
template<class Visitor> void
RecordForGroups::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (i, "i");
  std::forward<Visitor> (_visitor_) (ratio, "ratio");
  std::forward<Visitor> (_visitor_) (ordinary_bool, "ordinary_bool");
  std::forward<Visitor> (_visitor_) (threshold1, "threshold1");
  std::forward<Visitor> (_visitor_) (threshold2, "threshold2");
}
} // BseTest
#define aidacc_tests_t304_testpass_idl_FOREACH_IFACE_SEQ() \
  aidacc_tests_t304_testpass_idl_FOREACH_STEP (MandatoryNamespace::InterfaceSequence) \


#endif /* __CLNT__aidacc_tests_t304_testpass_idl */
// --- Generated by AidaCxxStub ---
#include "t304-testpass_interfaces.hh"

#ifndef __AIDA_CXXSTUB_CLIENT_CC__
#define __AIDA_CXXSTUB_CLIENT_CC__

namespace { // Anon

namespace __AIDA_Local__ {
using namespace Aida;

} } // Anon::__AIDA_Local__

#endif // __AIDA_CXXSTUB_CLIENT_CC__

#undef _
#define _(...)          __VA_ARGS__


// --- Implementations ---

namespace MandatoryNamespace {
FirstInterfaceHandle::FirstInterfaceHandle ()
{}
FirstInterfaceHandle::~FirstInterfaceHandle ()
{} // define empty dtor to emit vtable
FirstInterfaceHandle
FirstInterfaceHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<FirstInterfaceIface> (ifacep);
}
void
FirstInterfaceHandle::void_func ()
{
  return __AIDA_Local__::remote_callv (*this, &FirstInterfaceIface::void_func);
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_XFooRecord_ = {
  "typename=MandatoryNamespace.XFooRecord\0"
  "type=RECORD\0"
  "fields=single_bool;single_num;num64;single_float;single_string;sibling1;sibling2;multi1;multi2;multi3;multi4;enum_field;iface1;iface2;iface3;any1;any2;any3\0"
  "single_bool.type=BOOL\0"
  "single_num.type=INT32\0"
  "num64.type=INT64\0"
  "single_float.type=FLOAT64\0"
  "single_string.type=STRING\0"
  "sibling1.type=INT32\0"
  "sibling2.type=INT32\0"
  "multi1.type=INT32\0"
  "multi2.type=INT32\0"
  "multi3.type=INT32\0"
  "multi4.type=INT32\0"
  "enum_field.type=MandatoryNamespace.ExtensiveEnum\0"
  "iface1.type=MandatoryNamespace.FirstInterface\0"
  "iface2.type=MandatoryNamespace.FirstInterface\0"
  "iface3.type=MandatoryNamespace.FirstInterface\0"
  "any1.type=ANY\0"
  "any2.type=ANY\0"
  "any3.type=ANY\0"
};
const Aida::StringVector&
XFooRecord::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.XFooRecord");
  return sv;
}
bool
XFooRecord::operator== (const XFooRecord &other) const
{
  if (this->single_bool != other.single_bool) return false;
  if (this->single_num != other.single_num) return false;
  if (this->num64 != other.num64) return false;
  if (this->single_float != other.single_float) return false;
  if (this->single_string != other.single_string) return false;
  if (this->sibling1 != other.sibling1) return false;
  if (this->sibling2 != other.sibling2) return false;
  if (this->multi1 != other.multi1) return false;
  if (this->multi2 != other.multi2) return false;
  if (this->multi3 != other.multi3) return false;
  if (this->multi4 != other.multi4) return false;
  if (this->enum_field != other.enum_field) return false;
  if (this->iface1 != other.iface1) return false;
  if (this->iface2 != other.iface2) return false;
  if (this->iface3 != other.iface3) return false;
  if (this->any1 != other.any1) return false;
  if (this->any2 != other.any2) return false;
  if (this->any3 != other.any3) return false;
  return true;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_XFooSequence_ = {
  "typename=MandatoryNamespace.XFooSequence\0"
  "type=SEQUENCE\0"
  "fields=single_bool\0"
  "single_bool.type=BOOL\0"
};
const Aida::StringVector&
XFooSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.XFooSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_IntSequence_ = {
  "typename=MandatoryNamespace.IntSequence\0"
  "type=SEQUENCE\0"
  "fields=numx\0"
  "numx.type=INT32\0"
};
const Aida::StringVector&
IntSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.IntSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_FloatSequence_ = {
  "typename=MandatoryNamespace.FloatSequence\0"
  "type=SEQUENCE\0"
  "fields=fractalvalue\0"
  "fractalvalue.type=FLOAT64\0"
};
const Aida::StringVector&
FloatSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.FloatSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_StringSequence_ = {
  "typename=MandatoryNamespace.StringSequence\0"
  "type=SEQUENCE\0"
  "fields=blurb\0"
  "blurb.type=STRING\0"
};
const Aida::StringVector&
StringSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.StringSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_ExtensiveEnumSequence_ = {
  "typename=MandatoryNamespace.ExtensiveEnumSequence\0"
  "type=SEQUENCE\0"
  "fields=enum_elements\0"
  "enum_elements.type=MandatoryNamespace.ExtensiveEnum\0"
};
const Aida::StringVector&
ExtensiveEnumSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.ExtensiveEnumSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_RecordSequence_ = {
  "typename=MandatoryNamespace.RecordSequence\0"
  "type=SEQUENCE\0"
  "fields=repeatedfield\0"
  "repeatedfield.type=MandatoryNamespace.XFooRecord\0"
};
const Aida::StringVector&
RecordSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.RecordSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_SequenceSequence_ = {
  "typename=MandatoryNamespace.SequenceSequence\0"
  "type=SEQUENCE\0"
  "fields=moreints\0"
  "moreints.type=MandatoryNamespace.IntSequence\0"
};
const Aida::StringVector&
SequenceSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.SequenceSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_InterfaceSequence_ = {
  "typename=MandatoryNamespace.InterfaceSequence\0"
  "type=SEQUENCE\0"
  "fields=iface1\0"
  "iface1.type=MandatoryNamespace.FirstInterface\0"
};
const Aida::StringVector&
InterfaceSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.InterfaceSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_AnySequence_ = {
  "typename=MandatoryNamespace.AnySequence\0"
  "type=SEQUENCE\0"
  "fields=any_value\0"
  "any_value.type=ANY\0"
};
const Aida::StringVector&
AnySequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.AnySequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_NestedTypesRec_ = {
  "typename=MandatoryNamespace.NestedTypesRec\0"
  "type=RECORD\0"
  "fields=rec;seq\0"
  "rec.type=MandatoryNamespace.XFooRecord\0"
  "seq.type=MandatoryNamespace.XFooSequence\0"
};
const Aida::StringVector&
NestedTypesRec::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.NestedTypesRec");
  return sv;
}
bool
NestedTypesRec::operator== (const NestedTypesRec &other) const
{
  if (this->rec != other.rec) return false;
  if (this->seq != other.seq) return false;
  return true;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_NestedTypesSeq_ = {
  "typename=MandatoryNamespace.NestedTypesSeq\0"
  "type=SEQUENCE\0"
  "fields=ntr\0"
  "ntr.type=MandatoryNamespace.NestedTypesRec\0"
};
const Aida::StringVector&
NestedTypesSeq::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.NestedTypesSeq");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_NewRecord_ = {
  "typename=MandatoryNamespace.NewRecord\0"
  "type=RECORD\0"
  "fields=i;enum1;xfs;ntr\0"
  "i.type=INT32\0"
  "enum1.type=MandatoryNamespace.Enum1\0"
  "xfs.type=MandatoryNamespace.XFooSequence\0"
  "ntr.type=MandatoryNamespace.NestedTypesRec\0"
};
const Aida::StringVector&
NewRecord::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.NewRecord");
  return sv;
}
bool
NewRecord::operator== (const NewRecord &other) const
{
  if (this->i != other.i) return false;
  if (this->enum1 != other.enum1) return false;
  if (this->xfs != other.xfs) return false;
  if (this->ntr != other.ntr) return false;
  return true;
}

namespace Inner {
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Inner_InnerRecord_ = {
  "typename=MandatoryNamespace.Inner.InnerRecord\0"
  "type=RECORD\0"
  "fields=x;y;rec\0"
  "x.type=INT32\0"
  "y.type=INT32\0"
  "rec.type=MandatoryNamespace.NewRecord\0"
};
const Aida::StringVector&
InnerRecord::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.Inner.InnerRecord");
  return sv;
}
bool
InnerRecord::operator== (const InnerRecord &other) const
{
  if (this->x != other.x) return false;
  if (this->y != other.y) return false;
  if (this->rec != other.rec) return false;
  return true;
}
} // Inner
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Refer2Inner_ = {
  "typename=MandatoryNamespace.Refer2Inner\0"
  "type=RECORD\0"
  "fields=r\0"
  "r.type=MandatoryNamespace.Inner.InnerRecord\0"
};
const Aida::StringVector&
Refer2Inner::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.Refer2Inner");
  return sv;
}
bool
Refer2Inner::operator== (const Refer2Inner &other) const
{
  if (this->r != other.r) return false;
  return true;
}
} // MandatoryNamespace

namespace OtherNamespace {
static const Aida::IntrospectionRegistry __aida__aux__data__OtherNamespace_SomeRecord_ = {
  "typename=OtherNamespace.SomeRecord\0"
  "type=RECORD\0"
  "fields=r1;r2;r3;r4\0"
  "r1.type=MandatoryNamespace.NewRecord\0"
  "r2.type=MandatoryNamespace.NewRecord\0"
  "r3.type=MandatoryNamespace.Inner.InnerRecord\0"
  "r4.type=MandatoryNamespace.Inner.InnerRecord\0"
};
const Aida::StringVector&
SomeRecord::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("OtherNamespace.SomeRecord");
  return sv;
}
bool
SomeRecord::operator== (const SomeRecord &other) const
{
  if (this->r1 != other.r1) return false;
  if (this->r2 != other.r2) return false;
  if (this->r3 != other.r3) return false;
  if (this->r4 != other.r4) return false;
  return true;
}
} // OtherNamespace

namespace Auxdata {
static const Aida::IntrospectionRegistry __aida__aux__data__Auxdata_RecordWithAuxdata_ = {
  "typename=Auxdata.RecordWithAuxdata\0"
  "type=RECORD\0"
  "fields=aux_bool;aux32;aux64;auxf64;aux_str\0"
  "aux_bool.type=BOOL\0"
  "aux_bool.label=AuxBool\0"
  "aux_bool.blurb=A Boolean\0"
  "aux_bool.hints=rw\0"
  "aux_bool.default=0\0"
  "aux32.type=INT32\0"
  "aux32.label=Aux32\0"
  "aux32.blurb=The Bar number\0"
  "aux32.hints=rw\0"
  "aux32.default=10007.0\0"
  "aux64.type=INT64\0"
  "aux64.label=Aux64\0"
  "aux64.blurb=64bit auxillary number\0"
  "aux64.hints=rw\0"
  "aux64.default=1152921504606846976\0"
  "auxf64.type=FLOAT64\0"
  "auxf64.label=AuxF64\0"
  "auxf64.blurb=X coordinate\0"
  "auxf64.hints=ro\0"
  "auxf64.default=0.019\0"
  "aux_str.type=STRING\0"
  "aux_str.label=AuxStr\0"
  "aux_str.blurb=Specify text here\0"
  "aux_str.hints=rw\0"
  "aux_str.default=auxtest3\0"
};
const Aida::StringVector&
RecordWithAuxdata::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("Auxdata.RecordWithAuxdata");
  return sv;
}
bool
RecordWithAuxdata::operator== (const RecordWithAuxdata &other) const
{
  if (this->aux_bool != other.aux_bool) return false;
  if (this->aux32 != other.aux32) return false;
  if (this->aux64 != other.aux64) return false;
  if (this->auxf64 != other.auxf64) return false;
  if (this->aux_str != other.aux_str) return false;
  return true;
}
} // Auxdata

namespace InterfaceTests {
UIWidgetAreaHandle::UIWidgetAreaHandle ()
{}
UIWidgetAreaHandle::~UIWidgetAreaHandle ()
{} // define empty dtor to emit vtable
UIWidgetAreaHandle
UIWidgetAreaHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<UIWidgetAreaIface> (ifacep);
}
bool
UIWidgetAreaHandle::dummy () const
{
  return __AIDA_Local__::remote_callc (*this, &UIWidgetAreaIface::dummy);
}
void
UIWidgetAreaHandle::dummy (bool value)
{
  return __AIDA_Local__::remote_callv (*this, &UIWidgetAreaIface::dummy, value);
}
std::string
UIWidgetAreaHandle::on_click () const
{
  return __AIDA_Local__::remote_callc (*this, &UIWidgetAreaIface::on_click);
}
void
UIWidgetAreaHandle::on_click (const std::string &value)
{
  return __AIDA_Local__::remote_callv (*this, &UIWidgetAreaIface::on_click, value);
}
double
UIWidgetAreaHandle::simple_method ()
{
  return __AIDA_Local__::remote_callr (*this, &UIWidgetAreaIface::simple_method);
}
double
UIWidgetAreaHandle::single_arg (int arg_n)
{
  return __AIDA_Local__::remote_callr (*this, &UIWidgetAreaIface::single_arg, arg_n);
}
double
UIWidgetAreaHandle::single_arg2 (int arg_n)
{
  return __AIDA_Local__::remote_callr (*this, &UIWidgetAreaIface::single_arg2, arg_n);
}
double
UIWidgetAreaHandle::two_args (int arg_n,
                              double arg_r)
{
  return __AIDA_Local__::remote_callr (*this, &UIWidgetAreaIface::two_args, arg_n, arg_r);
}
double
UIWidgetAreaHandle::two_args2 (int arg_n,
                               double arg_r)
{
  return __AIDA_Local__::remote_callr (*this, &UIWidgetAreaIface::two_args2, arg_n, arg_r);
}
double
UIWidgetAreaHandle::multi_args (bool arg_b,
                                int64_t arg_n,
                                double arg_r,
                                int arg_i,
                                const std::string &arg_s,
                                double arg_y)
{
  return __AIDA_Local__::remote_callr (*this, &UIWidgetAreaIface::multi_args, arg_b, arg_n, arg_r, arg_i, arg_s, arg_y);
}
double
UIWidgetAreaHandle::self_method (UIWidgetAreaHandle &arg_ba1,
                                 UIWidgetAreaHandle &arg_ba2)
{
  return __AIDA_Local__::remote_callr (*this, &UIWidgetAreaIface::self_method, *arg_ba1.__iface__(), *arg_ba2.__iface__());
}
void
UIWidgetAreaHandle::void_method ()
{
  return __AIDA_Local__::remote_callv (*this, &UIWidgetAreaIface::void_method);
}
std::string
UIWidgetAreaHandle::on_click2out ()
{
  return __AIDA_Local__::remote_callr (*this, &UIWidgetAreaIface::on_click2out);
}
void
UIWidgetAreaHandle::on_click2in (const std::string &arg_command)
{
  return __AIDA_Local__::remote_callv (*this, &UIWidgetAreaIface::on_click2in, arg_command);
}
ParentHandle::ParentHandle ()
{}
ParentHandle::~ParentHandle ()
{} // define empty dtor to emit vtable
ParentHandle
ParentHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<ParentIface> (ifacep);
}
ChildHandle::ChildHandle ()
{}
ChildHandle::~ChildHandle ()
{} // define empty dtor to emit vtable
ChildHandle
ChildHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<ChildIface> (ifacep);
}
DescendantHandle::DescendantHandle ()
{}
DescendantHandle::~DescendantHandle ()
{} // define empty dtor to emit vtable
DescendantHandle
DescendantHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<DescendantIface> (ifacep);
}
GrandChildHandle::GrandChildHandle ()
{}
GrandChildHandle::~GrandChildHandle ()
{} // define empty dtor to emit vtable
GrandChildHandle
GrandChildHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<GrandChildIface> (ifacep);
}
static const Aida::IntrospectionRegistry __aida__aux__data__InterfaceTests_QuickRecord_ = {
  "typename=InterfaceTests.QuickRecord\0"
  "type=RECORD\0"
  "fields=int1;int2\0"
  "int1.type=INT32\0"
  "int2.type=INT32\0"
};
const Aida::StringVector&
QuickRecord::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("InterfaceTests.QuickRecord");
  return sv;
}
bool
QuickRecord::operator== (const QuickRecord &other) const
{
  if (this->int1 != other.int1) return false;
  if (this->int2 != other.int2) return false;
  return true;
}
static const Aida::IntrospectionRegistry __aida__aux__data__InterfaceTests_QuickSequence_ = {
  "typename=InterfaceTests.QuickSequence\0"
  "type=SEQUENCE\0"
  "fields=somefloat\0"
  "somefloat.type=FLOAT64\0"
};
const Aida::StringVector&
QuickSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("InterfaceTests.QuickSequence");
  return sv;
}
QuickIfaceHandle::QuickIfaceHandle ()
{}
QuickIfaceHandle::~QuickIfaceHandle ()
{} // define empty dtor to emit vtable
QuickIfaceHandle
QuickIfaceHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<QuickIfaceIface> (ifacep);
}
void
QuickIfaceHandle::simple_function (int arg_i)
{
  return __AIDA_Local__::remote_callv (*this, &QuickIfaceIface::simple_function, arg_i);
}
MethodTestInterfaceHandle::MethodTestInterfaceHandle ()
{}
MethodTestInterfaceHandle::~MethodTestInterfaceHandle ()
{} // define empty dtor to emit vtable
MethodTestInterfaceHandle
MethodTestInterfaceHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<MethodTestInterfaceIface> (ifacep);
}
void
MethodTestInterfaceHandle::method_with_void ()
{
  return __AIDA_Local__::remote_callv (*this, &MethodTestInterfaceIface::method_with_void);
}
bool
MethodTestInterfaceHandle::method_with_bools (bool arg_input,
                                              bool arg_optval)
{
  return __AIDA_Local__::remote_callr (*this, &MethodTestInterfaceIface::method_with_bools, arg_input, arg_optval);
}
int
MethodTestInterfaceHandle::method_with_ints32 (int arg_input,
                                               int arg_optval)
{
  return __AIDA_Local__::remote_callr (*this, &MethodTestInterfaceIface::method_with_ints32, arg_input, arg_optval);
}
int64_t
MethodTestInterfaceHandle::method_with_ints64 (int64_t arg_input,
                                               int64_t arg_optval)
{
  return __AIDA_Local__::remote_callr (*this, &MethodTestInterfaceIface::method_with_ints64, arg_input, arg_optval);
}
double
MethodTestInterfaceHandle::method_with_floats (double arg_input,
                                               double arg_optval)
{
  return __AIDA_Local__::remote_callr (*this, &MethodTestInterfaceIface::method_with_floats, arg_input, arg_optval);
}
std::string
MethodTestInterfaceHandle::method_with_string (const std::string &arg_input,
                                               const std::string &arg_optval)
{
  return __AIDA_Local__::remote_callr (*this, &MethodTestInterfaceIface::method_with_string, arg_input, arg_optval);
}
QuickEnum
MethodTestInterfaceHandle::method_with_enum (QuickEnum arg_input,
                                             QuickEnum arg_optval)
{
  return __AIDA_Local__::remote_callr (*this, &MethodTestInterfaceIface::method_with_enum, arg_input, arg_optval);
}
QuickRecord
MethodTestInterfaceHandle::method_with_record (const QuickRecord &arg_input,
                                               const QuickRecord &arg_optval)
{
  return __AIDA_Local__::remote_callr (*this, &MethodTestInterfaceIface::method_with_record, arg_input, arg_optval);
}
QuickSequence
MethodTestInterfaceHandle::method_with_sequence (const QuickSequence &arg_input,
                                                 const QuickSequence &arg_optval)
{
  return __AIDA_Local__::remote_callr (*this, &MethodTestInterfaceIface::method_with_sequence, arg_input, arg_optval);
}
GrandChildHandle
MethodTestInterfaceHandle::method_with_interface (GrandChildHandle &arg_input,
                                                  GrandChildHandle &arg_optval)
{
  return __AIDA_Local__::remote_callr (*this, &MethodTestInterfaceIface::method_with_interface, *arg_input.__iface__(), *arg_optval.__iface__());
}
Aida::Any
MethodTestInterfaceHandle::method_with_anys (const Aida::Any &arg_input,
                                             const Aida::Any &arg_optval)
{
  return __AIDA_Local__::remote_callr (*this, &MethodTestInterfaceIface::method_with_anys, arg_input, arg_optval);
}
QuickIfaceHandle
MethodTestInterfaceHandle::method_with_quickiface (QuickIfaceHandle &arg_input,
                                                   QuickIfaceHandle &arg_iface0)
{
  return __AIDA_Local__::remote_callr (*this, &MethodTestInterfaceIface::method_with_quickiface, *arg_input.__iface__(), *arg_iface0.__iface__());
}
SignalTestInterfaceHandle::SignalTestInterfaceHandle ()
{}
SignalTestInterfaceHandle::~SignalTestInterfaceHandle ()
{} // define empty dtor to emit vtable
SignalTestInterfaceHandle
SignalTestInterfaceHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<SignalTestInterfaceIface> (ifacep);
}
ChildInheritingSignalsHandle::ChildInheritingSignalsHandle ()
{}
ChildInheritingSignalsHandle::~ChildInheritingSignalsHandle ()
{} // define empty dtor to emit vtable
ChildInheritingSignalsHandle
ChildInheritingSignalsHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<ChildInheritingSignalsIface> (ifacep);
}
AnotherChildHandle::AnotherChildHandle ()
{}
AnotherChildHandle::~AnotherChildHandle ()
{} // define empty dtor to emit vtable
AnotherChildHandle
AnotherChildHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<AnotherChildIface> (ifacep);
}
PropertyTesterHandle::PropertyTesterHandle ()
{}
PropertyTesterHandle::~PropertyTesterHandle ()
{} // define empty dtor to emit vtable
PropertyTesterHandle
PropertyTesterHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<PropertyTesterIface> (ifacep);
}
bool
PropertyTesterHandle::bool_prop () const
{
  return __AIDA_Local__::remote_callc (*this, &PropertyTesterIface::bool_prop);
}
void
PropertyTesterHandle::bool_prop (bool value)
{
  return __AIDA_Local__::remote_callv (*this, &PropertyTesterIface::bool_prop, value);
}
int
PropertyTesterHandle::int32_prop () const
{
  return __AIDA_Local__::remote_callc (*this, &PropertyTesterIface::int32_prop);
}
void
PropertyTesterHandle::int32_prop (int value)
{
  return __AIDA_Local__::remote_callv (*this, &PropertyTesterIface::int32_prop, value);
}
int64_t
PropertyTesterHandle::int64_prop () const
{
  return __AIDA_Local__::remote_callc (*this, &PropertyTesterIface::int64_prop);
}
void
PropertyTesterHandle::int64_prop (int64_t value)
{
  return __AIDA_Local__::remote_callv (*this, &PropertyTesterIface::int64_prop, value);
}
double
PropertyTesterHandle::float64_prop () const
{
  return __AIDA_Local__::remote_callc (*this, &PropertyTesterIface::float64_prop);
}
void
PropertyTesterHandle::float64_prop (double value)
{
  return __AIDA_Local__::remote_callv (*this, &PropertyTesterIface::float64_prop, value);
}
std::string
PropertyTesterHandle::string_prop () const
{
  return __AIDA_Local__::remote_callc (*this, &PropertyTesterIface::string_prop);
}
void
PropertyTesterHandle::string_prop (const std::string &value)
{
  return __AIDA_Local__::remote_callv (*this, &PropertyTesterIface::string_prop, value);
}
QuickEnum
PropertyTesterHandle::enum_prop () const
{
  return __AIDA_Local__::remote_callc (*this, &PropertyTesterIface::enum_prop);
}
void
PropertyTesterHandle::enum_prop (QuickEnum value)
{
  return __AIDA_Local__::remote_callv (*this, &PropertyTesterIface::enum_prop, value);
}
QuickRecord
PropertyTesterHandle::record_prop () const
{
  return __AIDA_Local__::remote_callc (*this, &PropertyTesterIface::record_prop);
}
void
PropertyTesterHandle::record_prop (const QuickRecord &value)
{
  return __AIDA_Local__::remote_callv (*this, &PropertyTesterIface::record_prop, value);
}
QuickSequence
PropertyTesterHandle::sequence_prop () const
{
  return __AIDA_Local__::remote_callc (*this, &PropertyTesterIface::sequence_prop);
}
void
PropertyTesterHandle::sequence_prop (const QuickSequence &value)
{
  return __AIDA_Local__::remote_callv (*this, &PropertyTesterIface::sequence_prop, value);
}
GrandChildHandle
PropertyTesterHandle::interface_prop () const
{
  return __AIDA_Local__::remote_callc (*this, &PropertyTesterIface::interface_prop);
}
void
PropertyTesterHandle::interface_prop (GrandChildHandle value)
{
  return __AIDA_Local__::remote_callv (*this, &PropertyTesterIface::interface_prop, value.__iface__());
}
PropertyTesterHandle
PropertyTesterHandle::self_prop () const
{
  return __AIDA_Local__::remote_callc (*this, &PropertyTesterIface::self_prop);
}
void
PropertyTesterHandle::self_prop (PropertyTesterHandle value)
{
  return __AIDA_Local__::remote_callv (*this, &PropertyTesterIface::self_prop, value.__iface__());
}
Aida::Any
PropertyTesterHandle::any_prop () const
{
  return __AIDA_Local__::remote_callc (*this, &PropertyTesterIface::any_prop);
}
void
PropertyTesterHandle::any_prop (const Aida::Any &value)
{
  return __AIDA_Local__::remote_callv (*this, &PropertyTesterIface::any_prop, value);
}
} // InterfaceTests

namespace RapicornAidaTest {
UseIncludesHandle::UseIncludesHandle ()
{}
UseIncludesHandle::~UseIncludesHandle ()
{} // define empty dtor to emit vtable
UseIncludesHandle
UseIncludesHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<UseIncludesIface> (ifacep);
}
ButtonAreaHandle::ButtonAreaHandle ()
{}
ButtonAreaHandle::~ButtonAreaHandle ()
{} // define empty dtor to emit vtable
ButtonAreaHandle
ButtonAreaHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<ButtonAreaIface> (ifacep);
}
std::string
ButtonAreaHandle::on_click () const
{
  return __AIDA_Local__::remote_callc (*this, &ButtonAreaIface::on_click);
}
void
ButtonAreaHandle::on_click (const std::string &value)
{
  return __AIDA_Local__::remote_callv (*this, &ButtonAreaIface::on_click, value);
}
std::string
ButtonAreaHandle::on_click2 () const
{
  return __AIDA_Local__::remote_callc (*this, &ButtonAreaIface::on_click2);
}
void
ButtonAreaHandle::on_click2 (const std::string &value)
{
  return __AIDA_Local__::remote_callv (*this, &ButtonAreaIface::on_click2, value);
}
std::string
ButtonAreaHandle::on_click3 () const
{
  return __AIDA_Local__::remote_callc (*this, &ButtonAreaIface::on_click3);
}
void
ButtonAreaHandle::on_click3 (const std::string &value)
{
  return __AIDA_Local__::remote_callv (*this, &ButtonAreaIface::on_click3, value);
}
ClickType
ButtonAreaHandle::click_type () const
{
  return __AIDA_Local__::remote_callc (*this, &ButtonAreaIface::click_type);
}
void
ButtonAreaHandle::click_type (ClickType value)
{
  return __AIDA_Local__::remote_callv (*this, &ButtonAreaIface::click_type, value);
}
PureMethodsHandle::PureMethodsHandle ()
{}
PureMethodsHandle::~PureMethodsHandle ()
{} // define empty dtor to emit vtable
PureMethodsHandle
PureMethodsHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<PureMethodsIface> (ifacep);
}
int
PureMethodsHandle::pure_method (double arg_f)
{
  return __AIDA_Local__::remote_callr (*this, &PureMethodsIface::pure_method, arg_f);
}
} // RapicornAidaTest

namespace Other {
NameTestsHandle::NameTestsHandle ()
{}
NameTestsHandle::~NameTestsHandle ()
{} // define empty dtor to emit vtable
NameTestsHandle
NameTestsHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<NameTestsIface> (ifacep);
}
void
NameTestsHandle::args_from_other_namespace (const InterfaceTests::QuickRecord &arg_qr,
                                            RapicornAidaTest::ClickType arg_qe,
                                            const OtherNamespace::SomeRecord &arg_sr)
{
  return __AIDA_Local__::remote_callv (*this, &NameTestsIface::args_from_other_namespace, arg_qr, arg_qe, arg_sr);
}
} // Other

namespace BseTest {
CompressorHandle::CompressorHandle ()
{}
CompressorHandle::~CompressorHandle ()
{} // define empty dtor to emit vtable
CompressorHandle
CompressorHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<CompressorIface> (ifacep);
}
double
CompressorHandle::threshold () const
{
  return __AIDA_Local__::remote_callc (*this, &CompressorIface::threshold);
}
void
CompressorHandle::threshold (double value)
{
  return __AIDA_Local__::remote_callv (*this, &CompressorIface::threshold, value);
}
double
CompressorHandle::ratio () const
{
  return __AIDA_Local__::remote_callc (*this, &CompressorIface::ratio);
}
void
CompressorHandle::ratio (double value)
{
  return __AIDA_Local__::remote_callv (*this, &CompressorIface::ratio, value);
}
static const Aida::IntrospectionRegistry __aida__aux__data__BseTest_RecordForGroups_ = {
  "typename=BseTest.RecordForGroups\0"
  "type=RECORD\0"
  "fields=i;ratio;ordinary_bool;threshold1;threshold2\0"
  "i.type=INT32\0"
  "ratio.type=FLOAT64\0"
  "ratio.hints=w\0"
  "ratio.default=0\0"
  "ratio.group=Normal\0"
  "ordinary_bool.type=BOOL\0"
  "threshold1.type=FLOAT64\0"
  "threshold2.type=FLOAT64\0"
};
const Aida::StringVector&
RecordForGroups::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("BseTest.RecordForGroups");
  return sv;
}
bool
RecordForGroups::operator== (const RecordForGroups &other) const
{
  if (this->i != other.i) return false;
  if (this->ratio != other.ratio) return false;
  if (this->ordinary_bool != other.ordinary_bool) return false;
  if (this->threshold1 != other.threshold1) return false;
  if (this->threshold2 != other.threshold2) return false;
  return true;
}
SoundModuleHandle::SoundModuleHandle ()
{}
SoundModuleHandle::~SoundModuleHandle ()
{} // define empty dtor to emit vtable
SoundModuleHandle
SoundModuleHandle::__cast__ (const Aida::RemoteHandle &other)
{
  Aida::ImplicitBaseP &ifacep = const_cast<Aida::RemoteHandle&> (other).__iface_ptr__();
  return std::dynamic_pointer_cast<SoundModuleIface> (ifacep);
}
} // BseTest


namespace Aida {

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum1_ = {
  "typename=MandatoryNamespace.Enum1\0"
  "type=ENUM\0"
  "enumerators=E1_A\0"
  "E1_A.value=1\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum1c_ = {
  "typename=MandatoryNamespace.Enum1c\0"
  "type=ENUM\0"
  "enumerators=E1C_A\0"
  "E1C_A.value=1\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum2_ = {
  "typename=MandatoryNamespace.Enum2\0"
  "type=ENUM\0"
  "enumerators=E2_A;E2_B\0"
  "E2_A.value=1\0"
  "E2_B.value=2\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum2c_ = {
  "typename=MandatoryNamespace.Enum2c\0"
  "type=ENUM\0"
  "enumerators=E2C_A;E2C_B\0"
  "E2C_A.value=1\0"
  "E2C_B.value=2\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum3_ = {
  "typename=MandatoryNamespace.Enum3\0"
  "type=ENUM\0"
  "enumerators=E3_A;E3_B;E3_C\0"
  "E3_A.value=1\0"
  "E3_B.value=2\0"
  "E3_C.value=3\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum3c_ = {
  "typename=MandatoryNamespace.Enum3c\0"
  "type=ENUM\0"
  "enumerators=E3C_A;E3C_B;E3C_C\0"
  "E3C_A.value=1\0"
  "E3C_B.value=2\0"
  "E3C_C.value=3\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum4a_ = {
  "typename=MandatoryNamespace.Enum4a\0"
  "type=ENUM\0"
  "enumerators=E4A_A;E4A_B;E4A_C;E4A_D\0"
  "E4A_A.value=1\0"
  "E4A_B.value=2\0"
  "E4A_C.value=3\0"
  "E4A_D.value=4\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum4b_ = {
  "typename=MandatoryNamespace.Enum4b\0"
  "type=ENUM\0"
  "enumerators=E4B_A;E4B_B;E4B_C;E4B_D\0"
  "E4B_A.value=1\0"
  "E4B_B.value=2\0"
  "E4B_C.value=3\0"
  "E4B_D.value=4\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum4c_ = {
  "typename=MandatoryNamespace.Enum4c\0"
  "type=ENUM\0"
  "enumerators=E4C_A;E4C_B;E4C_C;E4C_D\0"
  "E4C_A.value=1\0"
  "E4C_B.value=2\0"
  "E4C_C.value=3\0"
  "E4C_D.value=4\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum4d_ = {
  "typename=MandatoryNamespace.Enum4d\0"
  "type=ENUM\0"
  "enumerators=E4D_A;E4D_B;E4D_C;E4D_D\0"
  "E4D_A.value=1\0"
  "E4D_B.value=2\0"
  "E4D_C.value=3\0"
  "E4D_D.value=4\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_ExtensiveEnum_ = {
  "typename=MandatoryNamespace.ExtensiveEnum\0"
  "type=ENUM\0"
  "enumerators=V1a;V1b;V2;V3;V4;V5;V6;V7;V8;V9;V10;V11;V12;V13;V14;V15;V16;V17;V18;V20;V21;V22;V23;V24;V25;V26;V27;V28;V30;V31;V32;V33;V34;V35;V36\0"
  "V1a.value=1\0"
  "V1b.value=1\0"
  "V2.value=2\0"
  "V3.value=3\0"
  "V3.label=" "v3" "\0"
  "V4.value=4\0"
  "V4.label=" _("v4") "\0"
  "V5.value=5\0"
  "V5.label=" "v5" "\0"
  "V5.blurb=" "V5" "\0"
  "V6.value=6\0"
  "V6.label=" _("v6") "\0"
  "V6.blurb=" "V6" "\0"
  "V7.value=7\0"
  "V7.label=" "v7" "\0"
  "V7.blurb=" _("V7") "\0"
  "V8.value=8\0"
  "V8.label=" _("v8") "\0"
  "V8.blurb=" _("V8") "\0"
  "V9.value=9\0"
  "V10.value=10\0"
  "V10.label=" "v10" "\0"
  "V11.value=11\0"
  "V11.label=" _("v11") "\0"
  "V12.value=12\0"
  "V12.label=" "v12" "\0"
  "V13.value=13\0"
  "V14.value=14\0"
  "V14.label=" _("v14") "\0"
  "V15.value=15\0"
  "V15.label=" "v15" "\0"
  "V15.blurb=" "V15" "\0"
  "V16.value=16\0"
  "V16.label=" _("v16") "\0"
  "V16.blurb=" "V16" "\0"
  "V17.value=17\0"
  "V17.label=" "v17" "\0"
  "V17.blurb=" _("V17") "\0"
  "V18.value=18\0"
  "V18.label=" _("v18") "\0"
  "V18.blurb=" _("V18") "\0"
  "V20.value=20\0"
  "V21.value=21\0"
  "V22.value=22\0"
  "V23.value=23\0"
  "V24.value=24\0"
  "V25.value=-9223372036854775808\0"
  "V26.value=9223372036854775807\0"
  "V27.value=9223372036854775807\0"
  "V28.value=-28\0"
  "V30.value=42\0"
  "V31.value=43\0"
  "V31.label=" "foo" "\0"
  "V32.value=42\0"
  "V33.value=43\0"
  "V33.label=" "foo" "\0"
  "V34.value=44\0"
  "V34.label=" "foo" "\0"
  "V34.blurb=" "foo" "\0"
  "V35.value=35\0"
  "V35.label=" "foo" "\0"
  "V36.value=42\0"
  "V36.label=" "foo" "\0"
  "V36.blurb=" "foo4" "\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__InterfaceTests_QuickEnum_ = {
  "typename=InterfaceTests.QuickEnum\0"
  "type=ENUM\0"
  "enumerators=ZERO\0"
  "ZERO.value=0\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__RapicornAidaTest_ClickType_ = {
  "typename=RapicornAidaTest.ClickType\0"
  "type=ENUM\0"
  "enumerators=CLICK_ON_PRESS;CLICK_ON_RELEASE;CLICK_SLOW_REPEAT;CLICK_FAST_REPEAT;CLICK_KEY_REPEAT\0"
  "CLICK_ON_PRESS.value=1\0"
  "CLICK_ON_RELEASE.value=2\0"
  "CLICK_SLOW_REPEAT.value=3\0"
  "CLICK_FAST_REPEAT.value=4\0"
  "CLICK_KEY_REPEAT.value=5\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__RapicornAidaTest_MathExpressions_ = {
  "typename=RapicornAidaTest.MathExpressions\0"
  "type=ENUM\0"
  "enumerators=RESULT_2;RESULT_5;RESULT_8;RESULT_6;RESULT_7;RESULT_16;RESULT_3;RESULT_24;RESULT_13;RESULT_m2;RESULT_77;RESULT_511\0"
  "RESULT_2.value=2\0"
  "RESULT_5.value=5\0"
  "RESULT_8.value=8\0"
  "RESULT_6.value=6\0"
  "RESULT_7.value=7\0"
  "RESULT_16.value=16\0"
  "RESULT_3.value=3\0"
  "RESULT_24.value=24\0"
  "RESULT_13.value=13\0"
  "RESULT_m2.value=-2\0"
  "RESULT_77.value=77\0"
  "RESULT_511.value=511\0"
};
} // Aida
