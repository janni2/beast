// --- Generated by AidaCxxStub ---
#ifndef __SRVT__aidacc_tests_t304_testpass_idl
#define __SRVT__aidacc_tests_t304_testpass_idl

#ifndef DOXYGEN

namespace MandatoryNamespace {
class FirstInterfaceIface;
} // MandatoryNamespace

namespace InterfaceTests {
class UIWidgetAreaIface;
class ParentIface;
class ChildIface;
class DescendantIface;
class GrandChildIface;
class QuickIfaceIface;
class MethodTestInterfaceIface;
class SignalTestInterfaceIface;
class ChildInheritingSignalsIface;
class AnotherChildIface;
class PropertyTesterIface;
} // InterfaceTests

namespace RapicornAidaTest {
class UseIncludesIface;
class ButtonAreaIface;
class PureMethodsIface;
} // RapicornAidaTest

namespace Other {
class NameTestsIface;
} // Other

namespace BseTest {
class CompressorIface;
class SoundModuleIface;
} // BseTest
#define __aidacc_tests_t304_testpass_idl_ifx__(interfacecodeextension)	interfacecodeextension

#include "t304-testpass_handles.hh"

namespace MandatoryNamespace {

class FirstInterfaceIface;
typedef std::shared_ptr<FirstInterfaceIface> FirstInterfaceIfaceP;
typedef std::weak_ptr  <FirstInterfaceIface> FirstInterfaceIfaceW;

class FirstInterfaceIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              FirstInterfaceIface ();
  virtual  /*dtor*/                    ~FirstInterfaceIface () override = 0;
public:
  FirstInterfaceHandle                  __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual void                          void_func           () = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};

class NestedTypesRec;

class NestedTypesSeq;
} // MandatoryNamespace

namespace InterfaceTests {

class UIWidgetAreaIface;
typedef std::shared_ptr<UIWidgetAreaIface> UIWidgetAreaIfaceP;
typedef std::weak_ptr  <UIWidgetAreaIface> UIWidgetAreaIfaceW;

class UIWidgetAreaIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              UIWidgetAreaIface ();
  virtual  /*dtor*/                    ~UIWidgetAreaIface () override = 0;
public:
  UIWidgetAreaHandle                    __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual bool                          dummy    () const = 0;
  virtual void                          dummy    (bool) = 0;
  virtual std::string                   on_click () const = 0;
  virtual void                          on_click (const std::string&) = 0;
  virtual double                        simple_method     () = 0;
  virtual double                        single_arg        (int n) = 0;
  virtual double                        single_arg2       (int n = 5) = 0;
  virtual double                        two_args          (int n,
                                                           double r) = 0;
  virtual double                        two_args2         (int n = 6,
                                                           double r = 7.7) = 0;
  virtual double                        multi_args        (bool b,
                                                           int64_t n,
                                                           double r,
                                                           int i,
                                                           const std::string &s = "String ding",
                                                           double y = 5) = 0;
  virtual double                        self_method       (UIWidgetAreaIface &ba1,
                                                           UIWidgetAreaIface &ba2) = 0;
  virtual void                          void_method       () = 0;
  virtual std::string                   on_click2out      () = 0;
  virtual void                          on_click2in       (const std::string &command) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "dummy", &UIWidgetAreaIface::dummy, &UIWidgetAreaIface::dummy);
    __visitor_ (*this, "on_click", &UIWidgetAreaIface::on_click, &UIWidgetAreaIface::on_click);
  }
};

class ParentIface;
typedef std::shared_ptr<ParentIface> ParentIfaceP;
typedef std::weak_ptr  <ParentIface> ParentIfaceW;

class ParentIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              ParentIface ();
  virtual  /*dtor*/                    ~ParentIface () override = 0;
public:
  ParentHandle                          __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};

class ChildIface;
typedef std::shared_ptr<ChildIface> ChildIfaceP;
typedef std::weak_ptr  <ChildIface> ChildIfaceW;

class ChildIface : public virtual ParentIface
{
protected:
  explicit                              ChildIface ();
  virtual  /*dtor*/                    ~ChildIface () override = 0;
public:
  ChildHandle                           __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->ParentIface::__accept_accessor__ (__visitor_);
  }
};

class DescendantIface;
typedef std::shared_ptr<DescendantIface> DescendantIfaceP;
typedef std::weak_ptr  <DescendantIface> DescendantIfaceW;

class DescendantIface : public virtual ChildIface
{
protected:
  explicit                              DescendantIface ();
  virtual  /*dtor*/                    ~DescendantIface () override = 0;
public:
  DescendantHandle                      __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->ChildIface::__accept_accessor__ (__visitor_);
  }
};

class GrandChildIface;
typedef std::shared_ptr<GrandChildIface> GrandChildIfaceP;
typedef std::weak_ptr  <GrandChildIface> GrandChildIfaceW;

class GrandChildIface : public virtual DescendantIface
{
protected:
  explicit                              GrandChildIface ();
  virtual  /*dtor*/                    ~GrandChildIface () override = 0;
public:
  GrandChildHandle                      __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->DescendantIface::__accept_accessor__ (__visitor_);
  }
};

class QuickIfaceIface;
typedef std::shared_ptr<QuickIfaceIface> QuickIfaceIfaceP;
typedef std::weak_ptr  <QuickIfaceIface> QuickIfaceIfaceW;

class QuickIfaceIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              QuickIfaceIface ();
  virtual  /*dtor*/                    ~QuickIfaceIface () override = 0;
public:
  QuickIfaceHandle                      __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual void                          simple_function (int i = 9) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};

class MethodTestInterfaceIface;
typedef std::shared_ptr<MethodTestInterfaceIface> MethodTestInterfaceIfaceP;
typedef std::weak_ptr  <MethodTestInterfaceIface> MethodTestInterfaceIfaceW;

class MethodTestInterfaceIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              MethodTestInterfaceIface ();
  virtual  /*dtor*/                    ~MethodTestInterfaceIface () override = 0;
public:
  MethodTestInterfaceHandle             __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual void                          method_with_void         () = 0;
  virtual bool                          method_with_bools        (bool input,
                                                                  bool optval = 0) = 0;
  virtual int                           method_with_ints32       (int input,
                                                                  int optval = -2) = 0;
  virtual int64_t                       method_with_ints64       (int64_t input,
                                                                  int64_t optval = 576460752303423488) = 0;
  virtual double                        method_with_floats       (double input,
                                                                  double optval = 309.9) = 0;
  virtual std::string                   method_with_string       (const std::string &input,
                                                                  const std::string &optval = "default") = 0;
  virtual QuickEnum                     method_with_enum         (QuickEnum input,
                                                                  QuickEnum optval = QuickEnum (0)) = 0;
  virtual QuickRecord                   method_with_record       (const QuickRecord &input,
                                                                  const QuickRecord &optval = QuickRecord()) = 0;
  virtual QuickSequence                 method_with_sequence     (const QuickSequence &input,
                                                                  const QuickSequence &optval = QuickSequence()) = 0;
  virtual GrandChildIfaceP              method_with_interface    (GrandChildIface &input,
                                                                  GrandChildIface &optval) = 0;
  virtual Aida::Any                     method_with_anys         (const Aida::Any &input,
                                                                  const Aida::Any &optval) = 0;
  virtual QuickIfaceIfaceP              method_with_quickiface   (QuickIfaceIface &input,
                                                                  QuickIfaceIface &iface0) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};

class SignalTestInterfaceIface;
typedef std::shared_ptr<SignalTestInterfaceIface> SignalTestInterfaceIfaceP;
typedef std::weak_ptr  <SignalTestInterfaceIface> SignalTestInterfaceIfaceW;

class SignalTestInterfaceIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              SignalTestInterfaceIface ();
  virtual  /*dtor*/                    ~SignalTestInterfaceIface () override = 0;
public:
  SignalTestInterfaceHandle             __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};

class ChildInheritingSignalsIface;
typedef std::shared_ptr<ChildInheritingSignalsIface> ChildInheritingSignalsIfaceP;
typedef std::weak_ptr  <ChildInheritingSignalsIface> ChildInheritingSignalsIfaceW;

class ChildInheritingSignalsIface : public virtual SignalTestInterfaceIface
{
protected:
  explicit                              ChildInheritingSignalsIface ();
  virtual  /*dtor*/                    ~ChildInheritingSignalsIface () override = 0;
public:
  ChildInheritingSignalsHandle          __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->SignalTestInterfaceIface::__accept_accessor__ (__visitor_);
  }
};

class AnotherChildIface;
typedef std::shared_ptr<AnotherChildIface> AnotherChildIfaceP;
typedef std::weak_ptr  <AnotherChildIface> AnotherChildIfaceW;

class AnotherChildIface : public virtual SignalTestInterfaceIface
{
protected:
  explicit                              AnotherChildIface ();
  virtual  /*dtor*/                    ~AnotherChildIface () override = 0;
public:
  AnotherChildHandle                    __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->SignalTestInterfaceIface::__accept_accessor__ (__visitor_);
  }
};

class PropertyTesterIface;
typedef std::shared_ptr<PropertyTesterIface> PropertyTesterIfaceP;
typedef std::weak_ptr  <PropertyTesterIface> PropertyTesterIfaceW;

class PropertyTesterIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              PropertyTesterIface ();
  virtual  /*dtor*/                    ~PropertyTesterIface () override = 0;
public:
  PropertyTesterHandle                  __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual bool                          bool_prop      () const = 0;
  virtual void                          bool_prop      (bool) = 0;
  virtual int                           int32_prop     () const = 0;
  virtual void                          int32_prop     (int) = 0;
  virtual int64_t                       int64_prop     () const = 0;
  virtual void                          int64_prop     (int64_t) = 0;
  virtual double                        float64_prop   () const = 0;
  virtual void                          float64_prop   (double) = 0;
  virtual std::string                   string_prop    () const = 0;
  virtual void                          string_prop    (const std::string&) = 0;
  virtual QuickEnum                     enum_prop      () const = 0;
  virtual void                          enum_prop      (QuickEnum) = 0;
  virtual QuickRecord                   record_prop    () const = 0;
  virtual void                          record_prop    (const QuickRecord&) = 0;
  virtual QuickSequence                 sequence_prop  () const = 0;
  virtual void                          sequence_prop  (const QuickSequence&) = 0;
  virtual GrandChildIfaceP              interface_prop () const = 0;
  virtual void                          interface_prop (GrandChildIface*) = 0;
  virtual PropertyTesterIfaceP          self_prop      () const = 0;
  virtual void                          self_prop      (PropertyTesterIface*) = 0;
  virtual Aida::Any                     any_prop       () const = 0;
  virtual void                          any_prop       (const Aida::Any&) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "bool_prop", &PropertyTesterIface::bool_prop, &PropertyTesterIface::bool_prop);
    __visitor_ (*this, "int32_prop", &PropertyTesterIface::int32_prop, &PropertyTesterIface::int32_prop);
    __visitor_ (*this, "int64_prop", &PropertyTesterIface::int64_prop, &PropertyTesterIface::int64_prop);
    __visitor_ (*this, "float64_prop", &PropertyTesterIface::float64_prop, &PropertyTesterIface::float64_prop);
    __visitor_ (*this, "string_prop", &PropertyTesterIface::string_prop, &PropertyTesterIface::string_prop);
    __visitor_ (*this, "enum_prop", &PropertyTesterIface::enum_prop, &PropertyTesterIface::enum_prop);
    __visitor_ (*this, "record_prop", &PropertyTesterIface::record_prop, &PropertyTesterIface::record_prop);
    __visitor_ (*this, "sequence_prop", &PropertyTesterIface::sequence_prop, &PropertyTesterIface::sequence_prop);
    __visitor_ (*this, "interface_prop", &PropertyTesterIface::interface_prop, &PropertyTesterIface::interface_prop);
    __visitor_ (*this, "self_prop", &PropertyTesterIface::self_prop, &PropertyTesterIface::self_prop);
    __visitor_ (*this, "any_prop", &PropertyTesterIface::any_prop, &PropertyTesterIface::any_prop);
  }
};
} // InterfaceTests

namespace RapicornAidaTest {

class UseIncludesIface;
typedef std::shared_ptr<UseIncludesIface> UseIncludesIfaceP;
typedef std::weak_ptr  <UseIncludesIface> UseIncludesIfaceW;

class UseIncludesIface : public virtual IncludeCheck::SomeInterfaceIface
{
protected:
  explicit                              UseIncludesIface ();
  virtual  /*dtor*/                    ~UseIncludesIface () override = 0;
public:
  UseIncludesHandle                     __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->IncludeCheck::SomeInterfaceIface::__accept_accessor__ (__visitor_);
  }
};

class ButtonAreaIface;
typedef std::shared_ptr<ButtonAreaIface> ButtonAreaIfaceP;
typedef std::weak_ptr  <ButtonAreaIface> ButtonAreaIfaceW;

class ButtonAreaIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              ButtonAreaIface ();
  virtual  /*dtor*/                    ~ButtonAreaIface () override = 0;
public:
  ButtonAreaHandle                      __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual std::string                   on_click   () const = 0;
  virtual void                          on_click   (const std::string&) = 0;
  virtual std::string                   on_click2  () const = 0;
  virtual void                          on_click2  (const std::string&) = 0;
  virtual std::string                   on_click3  () const = 0;
  virtual void                          on_click3  (const std::string&) = 0;
  virtual ClickType                     click_type () const = 0;
  virtual void                          click_type (ClickType) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "on_click", &ButtonAreaIface::on_click, &ButtonAreaIface::on_click);
    __visitor_ (*this, "on_click2", &ButtonAreaIface::on_click2, &ButtonAreaIface::on_click2);
    __visitor_ (*this, "on_click3", &ButtonAreaIface::on_click3, &ButtonAreaIface::on_click3);
    __visitor_ (*this, "click_type", &ButtonAreaIface::click_type, &ButtonAreaIface::click_type);
  }
};

class PureMethodsIface;
typedef std::shared_ptr<PureMethodsIface> PureMethodsIfaceP;
typedef std::weak_ptr  <PureMethodsIface> PureMethodsIfaceW;


class PureMethodsIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              PureMethodsIface ();
  virtual  /*dtor*/                    ~PureMethodsIface () override = 0;
public:
  PureMethodsHandle                     __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual int                           pure_method      (double f) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
} // RapicornAidaTest

namespace Other {

class NameTestsIface;
typedef std::shared_ptr<NameTestsIface> NameTestsIfaceP;
typedef std::weak_ptr  <NameTestsIface> NameTestsIfaceW;

class NameTestsIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              NameTestsIface ();
  virtual  /*dtor*/                    ~NameTestsIface () override = 0;
public:
  NameTestsHandle                       __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual void                          args_from_other_namespace (const InterfaceTests::QuickRecord &qr,
                                                                   RapicornAidaTest::ClickType qe,
                                                                   const OtherNamespace::SomeRecord &sr) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
} // Other

namespace BseTest {

class CompressorIface;
typedef std::shared_ptr<CompressorIface> CompressorIfaceP;
typedef std::weak_ptr  <CompressorIface> CompressorIfaceW;

class CompressorIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              CompressorIface ();
  virtual  /*dtor*/                    ~CompressorIface () override = 0;
public:
  CompressorHandle                      __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual double                        threshold () const = 0;
  virtual void                          threshold (double) = 0;
  virtual double                        ratio     () const = 0;
  virtual void                          ratio     (double) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "threshold", &CompressorIface::threshold, &CompressorIface::threshold);
    __visitor_ (*this, "ratio", &CompressorIface::ratio, &CompressorIface::ratio);
  }
};

class SoundModuleIface;
typedef std::shared_ptr<SoundModuleIface> SoundModuleIfaceP;
typedef std::weak_ptr  <SoundModuleIface> SoundModuleIfaceW;

class SoundModuleIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              SoundModuleIface ();
  virtual  /*dtor*/                    ~SoundModuleIface () override = 0;
public:
  SoundModuleHandle                     __handle__         ();
  virtual Aida::StringVector            __typelist_mt__    () const override;
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
} // BseTest

#define aidacc_tests_t304_testpass_idl_INTERFACE_LIST \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (MandatoryNamespace::FirstInterface) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::UIWidgetArea) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::Parent) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::Child) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::Descendant) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::GrandChild) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::QuickIface) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::MethodTestInterface) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::SignalTestInterface) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::ChildInheritingSignals) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::AnotherChild) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::PropertyTester) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (RapicornAidaTest::UseIncludes) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (RapicornAidaTest::ButtonArea) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (RapicornAidaTest::PureMethods) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (Other::NameTests) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (BseTest::Compressor) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (BseTest::SoundModule)

#else // DOXYGEN

namespace MandatoryNamespace {

/// IDL interface class for MandatoryNamespace::FirstInterface
/// @extends MandatoryNamespace::FirstInterface
class FirstInterfaceIface {};

/// @class MandatoryNamespace::FirstInterfaceImpl
/// @implements MandatoryNamespace::FirstInterface
} // MandatoryNamespace

namespace InterfaceTests {

/// IDL interface class for InterfaceTests::UIWidgetArea
/// @extends InterfaceTests::UIWidgetArea
class UIWidgetAreaIface {};

/// @class InterfaceTests::UIWidgetAreaImpl
/// @implements InterfaceTests::UIWidgetArea

/// IDL interface class for InterfaceTests::Parent
/// @extends InterfaceTests::Parent
class ParentIface {};

/// @class InterfaceTests::ParentImpl
/// @implements InterfaceTests::Parent

/// IDL interface class for InterfaceTests::Child
/// @extends InterfaceTests::Child
class ChildIface {};

/// @class InterfaceTests::ChildImpl
/// @implements InterfaceTests::Child

/// IDL interface class for InterfaceTests::Descendant
/// @extends InterfaceTests::Descendant
class DescendantIface {};

/// @class InterfaceTests::DescendantImpl
/// @implements InterfaceTests::Descendant

/// IDL interface class for InterfaceTests::GrandChild
/// @extends InterfaceTests::GrandChild
class GrandChildIface {};

/// @class InterfaceTests::GrandChildImpl
/// @implements InterfaceTests::GrandChild

/// IDL interface class for InterfaceTests::QuickIface
/// @extends InterfaceTests::QuickIface
class QuickIfaceIface {};

/// @class InterfaceTests::QuickIfaceImpl
/// @implements InterfaceTests::QuickIface

/// IDL interface class for InterfaceTests::MethodTestInterface
/// @extends InterfaceTests::MethodTestInterface
class MethodTestInterfaceIface {};

/// @class InterfaceTests::MethodTestInterfaceImpl
/// @implements InterfaceTests::MethodTestInterface

/// IDL interface class for InterfaceTests::SignalTestInterface
/// @extends InterfaceTests::SignalTestInterface
class SignalTestInterfaceIface {};

/// @class InterfaceTests::SignalTestInterfaceImpl
/// @implements InterfaceTests::SignalTestInterface

/// IDL interface class for InterfaceTests::ChildInheritingSignals
/// @extends InterfaceTests::ChildInheritingSignals
class ChildInheritingSignalsIface {};

/// @class InterfaceTests::ChildInheritingSignalsImpl
/// @implements InterfaceTests::ChildInheritingSignals

/// IDL interface class for InterfaceTests::AnotherChild
/// @extends InterfaceTests::AnotherChild
class AnotherChildIface {};

/// @class InterfaceTests::AnotherChildImpl
/// @implements InterfaceTests::AnotherChild

/// IDL interface class for InterfaceTests::PropertyTester
/// @extends InterfaceTests::PropertyTester
class PropertyTesterIface {};

/// @class InterfaceTests::PropertyTesterImpl
/// @implements InterfaceTests::PropertyTester
} // InterfaceTests

namespace RapicornAidaTest {

/// IDL interface class for RapicornAidaTest::UseIncludes
/// @extends RapicornAidaTest::UseIncludes
class UseIncludesIface {};

/// @class RapicornAidaTest::UseIncludesImpl
/// @implements RapicornAidaTest::UseIncludes

/// IDL interface class for RapicornAidaTest::ButtonArea
/// @extends RapicornAidaTest::ButtonArea
class ButtonAreaIface {};

/// @class RapicornAidaTest::ButtonAreaImpl
/// @implements RapicornAidaTest::ButtonArea

/// IDL interface class for RapicornAidaTest::PureMethods
/// @extends RapicornAidaTest::PureMethods
class PureMethodsIface {};

/// @class RapicornAidaTest::PureMethodsImpl
/// @implements RapicornAidaTest::PureMethods
} // RapicornAidaTest

namespace Other {

/// IDL interface class for Other::NameTests
/// @extends Other::NameTests
class NameTestsIface {};

/// @class Other::NameTestsImpl
/// @implements Other::NameTests
} // Other

namespace BseTest {

/// IDL interface class for BseTest::Compressor
/// @extends BseTest::Compressor
class CompressorIface {};

/// @class BseTest::CompressorImpl
/// @implements BseTest::Compressor

/// IDL interface class for BseTest::SoundModule
/// @extends BseTest::SoundModule
class SoundModuleIface {};

/// @class BseTest::SoundModuleImpl
/// @implements BseTest::SoundModule

} // BseTest
#endif // DOXYGEN

#endif /* __SRVT__aidacc_tests_t304_testpass_idl */
// --- Generated by AidaCxxStub ---
#include "t304-testpass_interfaces.hh"

#ifndef __AIDA_CXXSTUB_SERVER_CC__
#define __AIDA_CXXSTUB_SERVER_CC__

namespace { // Anon

namespace __AIDA_Local__ {
using namespace Aida;

static_assert (std::is_base_of<Aida::ImplicitBase, Aida::ImplicitBase>::value,
               "IDL interface base 'Aida::ImplicitBase' must derive 'Aida::ImplicitBase'");

// slot
template<class SharedPtr, class R, class... Args> std::function<R (Args...)>
slot (SharedPtr sp, R (*fp) (const SharedPtr&, Args...))
{
  return [sp, fp] (Args... args) { return fp (sp, args...); };
}

} } // Anon::__AIDA_Local__

#endif // __AIDA_CXXSTUB_SERVER_CC__


// --- Implementations ---

namespace MandatoryNamespace {

FirstInterfaceIface::FirstInterfaceIface ()
{}
FirstInterfaceIface::~FirstInterfaceIface ()
{} // define empty dtor to emit vtable
FirstInterfaceHandle
FirstInterfaceIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  FirstInterfaceHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<FirstInterfaceIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
FirstInterfaceHandle::FirstInterfaceHandle (const std::shared_ptr<FirstInterfaceIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<FirstInterfaceIface> (ec.adopt_deleter_mt (ifacep));
}
FirstInterfaceIface*
FirstInterfaceHandle::__iface__() const
{
  return dynamic_cast<FirstInterfaceIface*> (const_cast<FirstInterfaceHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
FirstInterfaceIface::__typelist_mt__ () const
{
  return { "MandatoryNamespace.FirstInterface", };
}
bool
FirstInterfaceIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}
} // MandatoryNamespace

namespace InterfaceTests {

UIWidgetAreaIface::UIWidgetAreaIface ()
{}
UIWidgetAreaIface::~UIWidgetAreaIface ()
{} // define empty dtor to emit vtable
UIWidgetAreaHandle
UIWidgetAreaIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  UIWidgetAreaHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<UIWidgetAreaIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
UIWidgetAreaHandle::UIWidgetAreaHandle (const std::shared_ptr<UIWidgetAreaIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<UIWidgetAreaIface> (ec.adopt_deleter_mt (ifacep));
}
UIWidgetAreaIface*
UIWidgetAreaHandle::__iface__() const
{
  return dynamic_cast<UIWidgetAreaIface*> (const_cast<UIWidgetAreaHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
UIWidgetAreaIface::__typelist_mt__ () const
{
  return { "InterfaceTests.UIWidgetArea", };
}
bool
UIWidgetAreaIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  const bool __all = __n.empty();
  const char *const __aux__dummy =
    "type=BOOL\0";
  if ((__all || __n == "dummy") &&
      __p (Aida::PropertyAccessorImpl<UIWidgetAreaIface,bool> ("dummy", *this, &UIWidgetAreaIface::dummy, &UIWidgetAreaIface::dummy, __aux__dummy)))
    return true;
  const char *const __aux__on_click =
    "type=STRING\0"
    "label=On CLick\0"
    "blurb=Command on button1 click\0"
    "hints=rw\0";
  if ((__all || __n == "on_click") &&
      __p (Aida::PropertyAccessorImpl<UIWidgetAreaIface,std::string> ("on_click", *this, &UIWidgetAreaIface::on_click, &UIWidgetAreaIface::on_click, __aux__on_click)))
    return true;
  return false;
}

ParentIface::ParentIface ()
{}
ParentIface::~ParentIface ()
{} // define empty dtor to emit vtable
ParentHandle
ParentIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  ParentHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<ParentIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
ParentHandle::ParentHandle (const std::shared_ptr<ParentIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<ParentIface> (ec.adopt_deleter_mt (ifacep));
}
ParentIface*
ParentHandle::__iface__() const
{
  return dynamic_cast<ParentIface*> (const_cast<ParentHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
ParentIface::__typelist_mt__ () const
{
  return { "InterfaceTests.Parent", };
}
bool
ParentIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}

ChildIface::ChildIface ()
{}
ChildIface::~ChildIface ()
{} // define empty dtor to emit vtable
ChildHandle
ChildIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  ChildHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<ChildIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
ChildHandle::ChildHandle (const std::shared_ptr<ChildIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<ChildIface> (ec.adopt_deleter_mt (ifacep));
}
ChildIface*
ChildHandle::__iface__() const
{
  return dynamic_cast<ChildIface*> (const_cast<ChildHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
ChildIface::__typelist_mt__ () const
{
  return { "InterfaceTests.Child", "InterfaceTests.Parent", };
}
bool
ChildIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  if (this->ParentIface::__access__ (__n, __p)) return true;
  return false;
}

DescendantIface::DescendantIface ()
{}
DescendantIface::~DescendantIface ()
{} // define empty dtor to emit vtable
DescendantHandle
DescendantIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  DescendantHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<DescendantIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
DescendantHandle::DescendantHandle (const std::shared_ptr<DescendantIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<DescendantIface> (ec.adopt_deleter_mt (ifacep));
}
DescendantIface*
DescendantHandle::__iface__() const
{
  return dynamic_cast<DescendantIface*> (const_cast<DescendantHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
DescendantIface::__typelist_mt__ () const
{
  return { "InterfaceTests.Descendant", "InterfaceTests.Parent", "InterfaceTests.Child", };
}
bool
DescendantIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  if (this->ChildIface::__access__ (__n, __p)) return true;
  return false;
}

GrandChildIface::GrandChildIface ()
{}
GrandChildIface::~GrandChildIface ()
{} // define empty dtor to emit vtable
GrandChildHandle
GrandChildIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  GrandChildHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<GrandChildIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
GrandChildHandle::GrandChildHandle (const std::shared_ptr<GrandChildIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<GrandChildIface> (ec.adopt_deleter_mt (ifacep));
}
GrandChildIface*
GrandChildHandle::__iface__() const
{
  return dynamic_cast<GrandChildIface*> (const_cast<GrandChildHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
GrandChildIface::__typelist_mt__ () const
{
  return { "InterfaceTests.GrandChild", "InterfaceTests.Parent", "InterfaceTests.Child", "InterfaceTests.Descendant", };
}
bool
GrandChildIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  if (this->DescendantIface::__access__ (__n, __p)) return true;
  return false;
}

QuickIfaceIface::QuickIfaceIface ()
{}
QuickIfaceIface::~QuickIfaceIface ()
{} // define empty dtor to emit vtable
QuickIfaceHandle
QuickIfaceIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  QuickIfaceHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<QuickIfaceIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
QuickIfaceHandle::QuickIfaceHandle (const std::shared_ptr<QuickIfaceIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<QuickIfaceIface> (ec.adopt_deleter_mt (ifacep));
}
QuickIfaceIface*
QuickIfaceHandle::__iface__() const
{
  return dynamic_cast<QuickIfaceIface*> (const_cast<QuickIfaceHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
QuickIfaceIface::__typelist_mt__ () const
{
  return { "InterfaceTests.QuickIface", };
}
bool
QuickIfaceIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}

MethodTestInterfaceIface::MethodTestInterfaceIface ()
{}
MethodTestInterfaceIface::~MethodTestInterfaceIface ()
{} // define empty dtor to emit vtable
MethodTestInterfaceHandle
MethodTestInterfaceIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  MethodTestInterfaceHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<MethodTestInterfaceIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
MethodTestInterfaceHandle::MethodTestInterfaceHandle (const std::shared_ptr<MethodTestInterfaceIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<MethodTestInterfaceIface> (ec.adopt_deleter_mt (ifacep));
}
MethodTestInterfaceIface*
MethodTestInterfaceHandle::__iface__() const
{
  return dynamic_cast<MethodTestInterfaceIface*> (const_cast<MethodTestInterfaceHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
MethodTestInterfaceIface::__typelist_mt__ () const
{
  return { "InterfaceTests.MethodTestInterface", };
}
bool
MethodTestInterfaceIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}

SignalTestInterfaceIface::SignalTestInterfaceIface ()
{}
SignalTestInterfaceIface::~SignalTestInterfaceIface ()
{} // define empty dtor to emit vtable
SignalTestInterfaceHandle
SignalTestInterfaceIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  SignalTestInterfaceHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<SignalTestInterfaceIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
SignalTestInterfaceHandle::SignalTestInterfaceHandle (const std::shared_ptr<SignalTestInterfaceIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<SignalTestInterfaceIface> (ec.adopt_deleter_mt (ifacep));
}
SignalTestInterfaceIface*
SignalTestInterfaceHandle::__iface__() const
{
  return dynamic_cast<SignalTestInterfaceIface*> (const_cast<SignalTestInterfaceHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
SignalTestInterfaceIface::__typelist_mt__ () const
{
  return { "InterfaceTests.SignalTestInterface", };
}
bool
SignalTestInterfaceIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}

ChildInheritingSignalsIface::ChildInheritingSignalsIface ()
{}
ChildInheritingSignalsIface::~ChildInheritingSignalsIface ()
{} // define empty dtor to emit vtable
ChildInheritingSignalsHandle
ChildInheritingSignalsIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  ChildInheritingSignalsHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<ChildInheritingSignalsIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
ChildInheritingSignalsHandle::ChildInheritingSignalsHandle (const std::shared_ptr<ChildInheritingSignalsIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<ChildInheritingSignalsIface> (ec.adopt_deleter_mt (ifacep));
}
ChildInheritingSignalsIface*
ChildInheritingSignalsHandle::__iface__() const
{
  return dynamic_cast<ChildInheritingSignalsIface*> (const_cast<ChildInheritingSignalsHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
ChildInheritingSignalsIface::__typelist_mt__ () const
{
  return { "InterfaceTests.ChildInheritingSignals", "InterfaceTests.SignalTestInterface", };
}
bool
ChildInheritingSignalsIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  if (this->SignalTestInterfaceIface::__access__ (__n, __p)) return true;
  return false;
}

AnotherChildIface::AnotherChildIface ()
{}
AnotherChildIface::~AnotherChildIface ()
{} // define empty dtor to emit vtable
AnotherChildHandle
AnotherChildIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  AnotherChildHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<AnotherChildIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
AnotherChildHandle::AnotherChildHandle (const std::shared_ptr<AnotherChildIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<AnotherChildIface> (ec.adopt_deleter_mt (ifacep));
}
AnotherChildIface*
AnotherChildHandle::__iface__() const
{
  return dynamic_cast<AnotherChildIface*> (const_cast<AnotherChildHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
AnotherChildIface::__typelist_mt__ () const
{
  return { "InterfaceTests.AnotherChild", "InterfaceTests.SignalTestInterface", };
}
bool
AnotherChildIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  if (this->SignalTestInterfaceIface::__access__ (__n, __p)) return true;
  return false;
}

PropertyTesterIface::PropertyTesterIface ()
{}
PropertyTesterIface::~PropertyTesterIface ()
{} // define empty dtor to emit vtable
PropertyTesterHandle
PropertyTesterIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  PropertyTesterHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<PropertyTesterIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
PropertyTesterHandle::PropertyTesterHandle (const std::shared_ptr<PropertyTesterIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<PropertyTesterIface> (ec.adopt_deleter_mt (ifacep));
}
PropertyTesterIface*
PropertyTesterHandle::__iface__() const
{
  return dynamic_cast<PropertyTesterIface*> (const_cast<PropertyTesterHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
PropertyTesterIface::__typelist_mt__ () const
{
  return { "InterfaceTests.PropertyTester", };
}
bool
PropertyTesterIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  const bool __all = __n.empty();
  const char *const __aux__bool_prop =
    "type=BOOL\0";
  if ((__all || __n == "bool_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,bool> ("bool_prop", *this, &PropertyTesterIface::bool_prop, &PropertyTesterIface::bool_prop, __aux__bool_prop)))
    return true;
  const char *const __aux__int32_prop =
    "type=INT32\0";
  if ((__all || __n == "int32_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,int> ("int32_prop", *this, &PropertyTesterIface::int32_prop, &PropertyTesterIface::int32_prop, __aux__int32_prop)))
    return true;
  const char *const __aux__int64_prop =
    "type=INT64\0";
  if ((__all || __n == "int64_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,int64_t> ("int64_prop", *this, &PropertyTesterIface::int64_prop, &PropertyTesterIface::int64_prop, __aux__int64_prop)))
    return true;
  const char *const __aux__float64_prop =
    "type=FLOAT64\0";
  if ((__all || __n == "float64_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,double> ("float64_prop", *this, &PropertyTesterIface::float64_prop, &PropertyTesterIface::float64_prop, __aux__float64_prop)))
    return true;
  const char *const __aux__string_prop =
    "type=STRING\0";
  if ((__all || __n == "string_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,std::string> ("string_prop", *this, &PropertyTesterIface::string_prop, &PropertyTesterIface::string_prop, __aux__string_prop)))
    return true;
  const char *const __aux__enum_prop =
    "type=InterfaceTests.QuickEnum\0";
  if ((__all || __n == "enum_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,QuickEnum> ("enum_prop", *this, &PropertyTesterIface::enum_prop, &PropertyTesterIface::enum_prop, __aux__enum_prop)))
    return true;
  const char *const __aux__record_prop =
    "type=InterfaceTests.QuickRecord\0";
  if ((__all || __n == "record_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,QuickRecord> ("record_prop", *this, &PropertyTesterIface::record_prop, &PropertyTesterIface::record_prop, __aux__record_prop)))
    return true;
  const char *const __aux__sequence_prop =
    "type=InterfaceTests.QuickSequence\0";
  if ((__all || __n == "sequence_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,QuickSequence> ("sequence_prop", *this, &PropertyTesterIface::sequence_prop, &PropertyTesterIface::sequence_prop, __aux__sequence_prop)))
    return true;
  const char *const __aux__interface_prop =
    "type=InterfaceTests.GrandChild\0";
  if ((__all || __n == "interface_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,GrandChildIface> ("interface_prop", *this, &PropertyTesterIface::interface_prop, &PropertyTesterIface::interface_prop, __aux__interface_prop)))
    return true;
  const char *const __aux__self_prop =
    "type=InterfaceTests.PropertyTester\0";
  if ((__all || __n == "self_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,PropertyTesterIface> ("self_prop", *this, &PropertyTesterIface::self_prop, &PropertyTesterIface::self_prop, __aux__self_prop)))
    return true;
  const char *const __aux__any_prop =
    "type=ANY\0";
  if ((__all || __n == "any_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,Aida::Any> ("any_prop", *this, &PropertyTesterIface::any_prop, &PropertyTesterIface::any_prop, __aux__any_prop)))
    return true;
  return false;
}
} // InterfaceTests

namespace RapicornAidaTest {

UseIncludesIface::UseIncludesIface ()
{}
UseIncludesIface::~UseIncludesIface ()
{} // define empty dtor to emit vtable
UseIncludesHandle
UseIncludesIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  UseIncludesHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<UseIncludesIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
UseIncludesHandle::UseIncludesHandle (const std::shared_ptr<UseIncludesIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<UseIncludesIface> (ec.adopt_deleter_mt (ifacep));
}
UseIncludesIface*
UseIncludesHandle::__iface__() const
{
  return dynamic_cast<UseIncludesIface*> (const_cast<UseIncludesHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
UseIncludesIface::__typelist_mt__ () const
{
  return { "RapicornAidaTest.UseIncludes", "IncludeCheck.SomeInterface", };
}
bool
UseIncludesIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  if (this->IncludeCheck::SomeInterfaceIface::__access__ (__n, __p)) return true;
  return false;
}

ButtonAreaIface::ButtonAreaIface ()
{}
ButtonAreaIface::~ButtonAreaIface ()
{} // define empty dtor to emit vtable
ButtonAreaHandle
ButtonAreaIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  ButtonAreaHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<ButtonAreaIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
ButtonAreaHandle::ButtonAreaHandle (const std::shared_ptr<ButtonAreaIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<ButtonAreaIface> (ec.adopt_deleter_mt (ifacep));
}
ButtonAreaIface*
ButtonAreaHandle::__iface__() const
{
  return dynamic_cast<ButtonAreaIface*> (const_cast<ButtonAreaHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
ButtonAreaIface::__typelist_mt__ () const
{
  return { "RapicornAidaTest.ButtonArea", };
}
bool
ButtonAreaIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  const bool __all = __n.empty();
  const char *const __aux__on_click =
    "type=STRING\0";
  if ((__all || __n == "on_click") &&
      __p (Aida::PropertyAccessorImpl<ButtonAreaIface,std::string> ("on_click", *this, &ButtonAreaIface::on_click, &ButtonAreaIface::on_click, __aux__on_click)))
    return true;
  const char *const __aux__on_click2 =
    "type=STRING\0";
  if ((__all || __n == "on_click2") &&
      __p (Aida::PropertyAccessorImpl<ButtonAreaIface,std::string> ("on_click2", *this, &ButtonAreaIface::on_click2, &ButtonAreaIface::on_click2, __aux__on_click2)))
    return true;
  const char *const __aux__on_click3 =
    "type=STRING\0";
  if ((__all || __n == "on_click3") &&
      __p (Aida::PropertyAccessorImpl<ButtonAreaIface,std::string> ("on_click3", *this, &ButtonAreaIface::on_click3, &ButtonAreaIface::on_click3, __aux__on_click3)))
    return true;
  const char *const __aux__click_type =
    "type=RapicornAidaTest.ClickType\0";
  if ((__all || __n == "click_type") &&
      __p (Aida::PropertyAccessorImpl<ButtonAreaIface,ClickType> ("click_type", *this, &ButtonAreaIface::click_type, &ButtonAreaIface::click_type, __aux__click_type)))
    return true;
  return false;
}

PureMethodsIface::PureMethodsIface ()
{}
PureMethodsIface::~PureMethodsIface ()
{} // define empty dtor to emit vtable
PureMethodsHandle
PureMethodsIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  PureMethodsHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<PureMethodsIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
PureMethodsHandle::PureMethodsHandle (const std::shared_ptr<PureMethodsIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<PureMethodsIface> (ec.adopt_deleter_mt (ifacep));
}
PureMethodsIface*
PureMethodsHandle::__iface__() const
{
  return dynamic_cast<PureMethodsIface*> (const_cast<PureMethodsHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
PureMethodsIface::__typelist_mt__ () const
{
  return { "RapicornAidaTest.PureMethods", };
}
bool
PureMethodsIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}
} // RapicornAidaTest

namespace Other {

NameTestsIface::NameTestsIface ()
{}
NameTestsIface::~NameTestsIface ()
{} // define empty dtor to emit vtable
NameTestsHandle
NameTestsIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  NameTestsHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<NameTestsIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
NameTestsHandle::NameTestsHandle (const std::shared_ptr<NameTestsIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<NameTestsIface> (ec.adopt_deleter_mt (ifacep));
}
NameTestsIface*
NameTestsHandle::__iface__() const
{
  return dynamic_cast<NameTestsIface*> (const_cast<NameTestsHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
NameTestsIface::__typelist_mt__ () const
{
  return { "Other.NameTests", };
}
bool
NameTestsIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}
} // Other

namespace BseTest {

CompressorIface::CompressorIface ()
{}
CompressorIface::~CompressorIface ()
{} // define empty dtor to emit vtable
CompressorHandle
CompressorIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  CompressorHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<CompressorIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
CompressorHandle::CompressorHandle (const std::shared_ptr<CompressorIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<CompressorIface> (ec.adopt_deleter_mt (ifacep));
}
CompressorIface*
CompressorHandle::__iface__() const
{
  return dynamic_cast<CompressorIface*> (const_cast<CompressorHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
CompressorIface::__typelist_mt__ () const
{
  return { "BseTest.Compressor", };
}
bool
CompressorIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  const bool __all = __n.empty();
  const char *const __aux__threshold =
    "type=FLOAT64\0"
    "hints=w\0"
    "default=0\0"
    "group=Compatibility Settings\0";
  if ((__all || __n == "threshold") &&
      __p (Aida::PropertyAccessorImpl<CompressorIface,double> ("threshold", *this, &CompressorIface::threshold, &CompressorIface::threshold, __aux__threshold)))
    return true;
  const char *const __aux__ratio =
    "type=FLOAT64\0"
    "hints=w\0"
    "default=0\0"
    "group=Compatibility Settings\0";
  if ((__all || __n == "ratio") &&
      __p (Aida::PropertyAccessorImpl<CompressorIface,double> ("ratio", *this, &CompressorIface::ratio, &CompressorIface::ratio, __aux__ratio)))
    return true;
  return false;
}

SoundModuleIface::SoundModuleIface ()
{}
SoundModuleIface::~SoundModuleIface ()
{} // define empty dtor to emit vtable
SoundModuleHandle
SoundModuleIface::__handle__()
{
  Aida::ExecutionContext &ec = this->__execution_context_mt__();
  SoundModuleHandle handle;
  handle.__iface_ptr__() = std::dynamic_pointer_cast<SoundModuleIface> (ec.adopt_deleter_mt (this->shared_from_this()));
  return handle;
}
SoundModuleHandle::SoundModuleHandle (const std::shared_ptr<SoundModuleIface> &ifacep)
{
  if (!ifacep)
    return;
  Aida::ExecutionContext &ec = ifacep->__execution_context_mt__();
  __iface_ptr__() = std::dynamic_pointer_cast<SoundModuleIface> (ec.adopt_deleter_mt (ifacep));
}
SoundModuleIface*
SoundModuleHandle::__iface__() const
{
  return dynamic_cast<SoundModuleIface*> (const_cast<SoundModuleHandle*> (this)->__iface_ptr__().get());
}
Aida::StringVector
SoundModuleIface::__typelist_mt__ () const
{
  return { "BseTest.SoundModule", };
}
bool
SoundModuleIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}
} // BseTest
