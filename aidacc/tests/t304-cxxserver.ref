// --- Generated by AidaCxxStub ---
#ifndef __SRVT__aidacc_tests_t304_testpass_idl
#define __SRVT__aidacc_tests_t304_testpass_idl

#ifndef DOXYGEN

namespace MandatoryNamespace {
class FirstInterfaceIface;
} // MandatoryNamespace

namespace InterfaceTests {
class UIWidgetAreaIface;
class ParentIface;
class ChildIface;
class DescendantIface;
class GrandChildIface;
class QuickIfaceIface;
class MethodTestInterfaceIface;
class SignalTestInterfaceIface;
class ChildInheritingSignalsIface;
class AnotherChildIface;
class PropertyTesterIface;
} // InterfaceTests

namespace RapicornAidaTest {
class UseIncludesIface;
class ButtonAreaIface;
class PureMethodsIface;
} // RapicornAidaTest

namespace Other {
class NameTestsIface;
} // Other

namespace BseTest {
class CompressorIface;
class SoundModuleIface;
} // BseTest
#define __aidacc_tests_t304_testpass_idl_ifx__(interfacecodeextension)	interfacecodeextension

#include <aidacc/aida.hh>

namespace MandatoryNamespace {

enum class Enum1 : int64_t {
  E1_A = 1,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum1);
inline std::string to_string   (Enum1 ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum1 &ev) { ev = Aida::enum_value_from_string<Enum1> (en); return true; }

enum class Enum1c : int64_t {
  E1C_A = 1,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum1c);
inline std::string to_string   (Enum1c ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum1c &ev) { ev = Aida::enum_value_from_string<Enum1c> (en); return true; }

enum class Enum2 : int64_t {
  E2_A = 1,
  E2_B = 2,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum2);
inline std::string to_string   (Enum2 ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum2 &ev) { ev = Aida::enum_value_from_string<Enum2> (en); return true; }

enum class Enum2c : int64_t {
  E2C_A = 1,
  E2C_B = 2,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum2c);
inline std::string to_string   (Enum2c ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum2c &ev) { ev = Aida::enum_value_from_string<Enum2c> (en); return true; }

enum class Enum3 : int64_t {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum3);
inline std::string to_string   (Enum3 ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum3 &ev) { ev = Aida::enum_value_from_string<Enum3> (en); return true; }

enum class Enum3c : int64_t {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum3c);
inline std::string to_string   (Enum3c ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum3c &ev) { ev = Aida::enum_value_from_string<Enum3c> (en); return true; }

enum class Enum4a : int64_t {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum4a);
inline std::string to_string   (Enum4a ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum4a &ev) { ev = Aida::enum_value_from_string<Enum4a> (en); return true; }

enum class Enum4b : int64_t {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum4b);
inline std::string to_string   (Enum4b ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum4b &ev) { ev = Aida::enum_value_from_string<Enum4b> (en); return true; }

enum class Enum4c : int64_t {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum4c);
inline std::string to_string   (Enum4c ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum4c &ev) { ev = Aida::enum_value_from_string<Enum4c> (en); return true; }

enum class Enum4d : int64_t {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
AIDA_DEFINE_ENUM_EQUALITY (Enum4d);
inline std::string to_string   (Enum4d ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, Enum4d &ev) { ev = Aida::enum_value_from_string<Enum4d> (en); return true; }

enum class ExtensiveEnum : int64_t {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = (-9223372036854775807 - 1),
  V26 = 9223372036854775807,
  V27 = 9223372036854775807,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 35,
  V36 = 42, // "foo4"
};
AIDA_DEFINE_ENUM_EQUALITY (ExtensiveEnum);
inline std::string to_string   (ExtensiveEnum ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, ExtensiveEnum &ev) { ev = Aida::enum_value_from_string<ExtensiveEnum> (en); return true; }
} // MandatoryNamespace

namespace InterfaceTests {

enum class QuickEnum : int64_t {
  ZERO = 0,
};
AIDA_DEFINE_ENUM_EQUALITY (QuickEnum);
inline std::string to_string   (QuickEnum ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, QuickEnum &ev) { ev = Aida::enum_value_from_string<QuickEnum> (en); return true; }
} // InterfaceTests

namespace RapicornAidaTest {

enum class ClickType : int64_t {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};
AIDA_DEFINE_ENUM_EQUALITY (ClickType);
inline std::string to_string   (ClickType ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, ClickType &ev) { ev = Aida::enum_value_from_string<ClickType> (en); return true; }

enum class MathExpressions : int64_t {
  RESULT_2 = 2,
  RESULT_5 = 5,
  RESULT_8 = 8,
  RESULT_6 = 6,
  RESULT_7 = 7,
  RESULT_16 = 16,
  RESULT_3 = 3,
  RESULT_24 = 24,
  RESULT_13 = 13,
  RESULT_m2 = -2,
  RESULT_77 = 77,
  RESULT_511 = 511,
};
AIDA_DEFINE_ENUM_EQUALITY (MathExpressions);
inline std::string to_string   (MathExpressions ev)                         { return Aida::enum_value_to_string (ev); }
inline bool        from_string (const std::string &en, MathExpressions &ev) { ev = Aida::enum_value_from_string<MathExpressions> (en); return true; }
} // RapicornAidaTest

namespace MandatoryNamespace {

class FirstInterfaceIface;
typedef std::shared_ptr<FirstInterfaceIface> FirstInterfaceIfaceP;
typedef std::weak_ptr  <FirstInterfaceIface> FirstInterfaceIfaceW;

class FirstInterfaceIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              FirstInterfaceIface ();
  virtual  /*dtor*/                    ~FirstInterfaceIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual void                          void_func           () = 0;
};

class XFooRecord
{
public:
  bool                          single_bool = 0;
  int                           single_num = 0;
  int64_t                       num64 = 0;
  double                        single_float = 0;
  std::string                   single_string;
  int                           sibling1 = 0;
  int                           sibling2 = 0;
  int                           multi1 = 0;
  int                           multi2 = 0;
  int                           multi3 = 0;
  int                           multi4 = 0;
  ExtensiveEnum                 enum_field = ExtensiveEnum (0);
  FirstInterfaceIfaceP          iface1;
  FirstInterfaceIfaceP          iface2;
  FirstInterfaceIfaceP          iface3;
  Aida::Any                     any1;
  Aida::Any                     any2;
  Aida::Any                     any3;
  inline                        XFooRecord () = default;
  inline                        XFooRecord (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const XFooRecord &other) const;
  bool                          operator!=   (const XFooRecord &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<XFooRecord*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};

class XFooSequence : public std::vector<bool>
{
public:
  typedef std::vector<bool> Sequence;
  inline                        XFooSequence () = default;
  inline                        XFooSequence (const Aida::AnySeq &s);
  explicit                      XFooSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class IntSequence : public std::vector<int>
{
public:
  typedef std::vector<int> Sequence;
  inline                        IntSequence () = default;
  inline                        IntSequence (const Aida::AnySeq &s);
  explicit                      IntSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class FloatSequence : public std::vector<double>
{
public:
  typedef std::vector<double> Sequence;
  inline                        FloatSequence () = default;
  inline                        FloatSequence (const Aida::AnySeq &s);
  explicit                      FloatSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class StringSequence : public std::vector<std::string>
{
public:
  typedef std::vector<std::string> Sequence;
  inline                        StringSequence () = default;
  inline                        StringSequence (const Aida::AnySeq &s);
  explicit                      StringSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class ExtensiveEnumSequence : public std::vector<ExtensiveEnum>
{
public:
  typedef std::vector<ExtensiveEnum> Sequence;
  inline                        ExtensiveEnumSequence () = default;
  inline                        ExtensiveEnumSequence (const Aida::AnySeq &s);
  explicit                      ExtensiveEnumSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class RecordSequence : public std::vector<XFooRecord>
{
public:
  typedef std::vector<XFooRecord> Sequence;
  inline                        RecordSequence () = default;
  inline                        RecordSequence (const Aida::AnySeq &s);
  explicit                      RecordSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class SequenceSequence : public std::vector<IntSequence>
{
public:
  typedef std::vector<IntSequence> Sequence;
  inline                        SequenceSequence () = default;
  inline                        SequenceSequence (const Aida::AnySeq &s);
  explicit                      SequenceSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class InterfaceSequence : public std::vector<FirstInterfaceIfaceP>
{
public:
  typedef std::vector<FirstInterfaceIfaceP> Sequence;
  inline                        InterfaceSequence () = default;
  inline                        InterfaceSequence (const Aida::AnySeq &s);
  explicit                      InterfaceSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class AnySequence : public std::vector<Aida::Any>
{
public:
  typedef std::vector<Aida::Any> Sequence;
  inline                        AnySequence () = default;
  inline                        AnySequence (const Aida::AnySeq &s);
  explicit                      AnySequence (std::initializer_list<value_type> il) : Sequence (il) {};
  static const Aida::StringVector& __typedata__ ();
};

class NestedTypesRec;

class NestedTypesSeq;

class NestedTypesRec
{
public:
  XFooRecord                    rec;
  XFooSequence                  seq;
  inline                        NestedTypesRec () = default;
  inline                        NestedTypesRec (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const NestedTypesRec &other) const;
  bool                          operator!=   (const NestedTypesRec &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<NestedTypesRec*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};

class NestedTypesSeq : public std::vector<NestedTypesRec>
{
public:
  typedef std::vector<NestedTypesRec> Sequence;
  inline                        NestedTypesSeq () = default;
  inline                        NestedTypesSeq (const Aida::AnySeq &s);
  explicit                      NestedTypesSeq (std::initializer_list<value_type> il) : Sequence (il) {};
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class NewRecord
{
public:
  int                           i = 0;
  Enum1                         enum1 = Enum1 (0);
  XFooSequence                  xfs;
  NestedTypesRec                ntr;
  inline                        NewRecord () = default;
  inline                        NewRecord (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const NewRecord &other) const;
  bool                          operator!=   (const NewRecord &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<NewRecord*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};

namespace Inner {

class InnerRecord
{
public:
  int                           x = 0;
  int                           y = 0;
  NewRecord                     rec;
  inline                        InnerRecord () = default;
  inline                        InnerRecord (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const InnerRecord &other) const;
  bool                          operator!=   (const InnerRecord &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<InnerRecord*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};
} // Inner

class Refer2Inner
{
public:
  Inner::InnerRecord            r;
  inline                        Refer2Inner () = default;
  inline                        Refer2Inner (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const Refer2Inner &other) const;
  bool                          operator!=   (const Refer2Inner &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<Refer2Inner*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};
} // MandatoryNamespace

namespace OtherNamespace {

class SomeRecord
{
public:
  MandatoryNamespace::NewRecord r1;
  MandatoryNamespace::NewRecord r2;
  MandatoryNamespace::Inner::InnerRecord r3;
  MandatoryNamespace::Inner::InnerRecord r4;
  inline                        SomeRecord () = default;
  inline                        SomeRecord (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const SomeRecord &other) const;
  bool                          operator!=   (const SomeRecord &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<SomeRecord*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};
} // OtherNamespace

namespace Auxdata {

class RecordWithAuxdata
{
public:
  bool                          aux_bool = 0;
  int                           aux32 = 0;
  int64_t                       aux64 = 0;
  double                        auxf64 = 0;
  std::string                   aux_str;
  inline                        RecordWithAuxdata () = default;
  inline                        RecordWithAuxdata (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const RecordWithAuxdata &other) const;
  bool                          operator!=   (const RecordWithAuxdata &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<RecordWithAuxdata*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};
} // Auxdata

namespace InterfaceTests {

class UIWidgetAreaIface;
typedef std::shared_ptr<UIWidgetAreaIface> UIWidgetAreaIfaceP;
typedef std::weak_ptr  <UIWidgetAreaIface> UIWidgetAreaIfaceW;

class UIWidgetAreaIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              UIWidgetAreaIface ();
  virtual  /*dtor*/                    ~UIWidgetAreaIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual bool                          dummy    () const = 0;
  virtual void                          dummy    (bool) = 0;
  virtual std::string                   on_click () const = 0;
  virtual void                          on_click (const std::string&) = 0;
  virtual double                        simple_method     () = 0;
  virtual double                        single_arg        (int n) = 0;
  virtual double                        single_arg2       (int n = 5) = 0;
  virtual double                        two_args          (int n,
                                                           double r) = 0;
  virtual double                        two_args2         (int n = 6,
                                                           double r = 7.7) = 0;
  virtual double                        multi_args        (bool b,
                                                           int64_t n,
                                                           double r,
                                                           int i,
                                                           const std::string &s = "String ding",
                                                           double y = 5) = 0;
  virtual double                        self_method       (UIWidgetAreaIface &ba1,
                                                           UIWidgetAreaIface &ba2) = 0;
  virtual void                          void_method       () = 0;
  virtual std::string                   on_click2out      () = 0;
  virtual void                          on_click2in       (const std::string &command) = 0;
};

class ParentIface;
typedef std::shared_ptr<ParentIface> ParentIfaceP;
typedef std::weak_ptr  <ParentIface> ParentIfaceW;

class ParentIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              ParentIface ();
  virtual  /*dtor*/                    ~ParentIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
};

class ChildIface;
typedef std::shared_ptr<ChildIface> ChildIfaceP;
typedef std::weak_ptr  <ChildIface> ChildIfaceW;

class ChildIface : public virtual ParentIface
{
protected:
  explicit                              ChildIface ();
  virtual  /*dtor*/                    ~ChildIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
};

class DescendantIface;
typedef std::shared_ptr<DescendantIface> DescendantIfaceP;
typedef std::weak_ptr  <DescendantIface> DescendantIfaceW;

class DescendantIface : public virtual ChildIface
{
protected:
  explicit                              DescendantIface ();
  virtual  /*dtor*/                    ~DescendantIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
};

class GrandChildIface;
typedef std::shared_ptr<GrandChildIface> GrandChildIfaceP;
typedef std::weak_ptr  <GrandChildIface> GrandChildIfaceW;

class GrandChildIface : public virtual DescendantIface
{
protected:
  explicit                              GrandChildIface ();
  virtual  /*dtor*/                    ~GrandChildIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
};

class QuickRecord
{
public:
  int                           int1 = 0;
  int                           int2 = 0;
  inline                        QuickRecord () = default;
  inline                        QuickRecord (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const QuickRecord &other) const;
  bool                          operator!=   (const QuickRecord &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<QuickRecord*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};

class QuickSequence : public std::vector<double>
{
public:
  typedef std::vector<double> Sequence;
  inline                        QuickSequence () = default;
  inline                        QuickSequence (const Aida::AnySeq &s);
  explicit                      QuickSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  static const Aida::StringVector& __typedata__ ();
  inline operator               Aida::AnySeq      () const;
};

class QuickIfaceIface;
typedef std::shared_ptr<QuickIfaceIface> QuickIfaceIfaceP;
typedef std::weak_ptr  <QuickIfaceIface> QuickIfaceIfaceW;

class QuickIfaceIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              QuickIfaceIface ();
  virtual  /*dtor*/                    ~QuickIfaceIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual void                          simple_function (int i = 9) = 0;
};

class MethodTestInterfaceIface;
typedef std::shared_ptr<MethodTestInterfaceIface> MethodTestInterfaceIfaceP;
typedef std::weak_ptr  <MethodTestInterfaceIface> MethodTestInterfaceIfaceW;

class MethodTestInterfaceIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              MethodTestInterfaceIface ();
  virtual  /*dtor*/                    ~MethodTestInterfaceIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual void                          method_with_void         () = 0;
  virtual bool                          method_with_bools        (bool input,
                                                                  bool optval = 0) = 0;
  virtual int                           method_with_ints32       (int input,
                                                                  int optval = -2) = 0;
  virtual int64_t                       method_with_ints64       (int64_t input,
                                                                  int64_t optval = 576460752303423488) = 0;
  virtual double                        method_with_floats       (double input,
                                                                  double optval = 309.9) = 0;
  virtual std::string                   method_with_string       (const std::string &input,
                                                                  const std::string &optval = "default") = 0;
  virtual QuickEnum                     method_with_enum         (QuickEnum input,
                                                                  QuickEnum optval = QuickEnum (0)) = 0;
  virtual QuickRecord                   method_with_record       (const QuickRecord &input,
                                                                  const QuickRecord &optval = QuickRecord()) = 0;
  virtual QuickSequence                 method_with_sequence     (const QuickSequence &input,
                                                                  const QuickSequence &optval = QuickSequence()) = 0;
  virtual GrandChildIfaceP              method_with_interface    (GrandChildIface &input,
                                                                  GrandChildIface &optval) = 0;
  virtual Aida::Any                     method_with_anys         (const Aida::Any &input,
                                                                  const Aida::Any &optval) = 0;
  virtual QuickIfaceIfaceP              method_with_quickiface   (QuickIfaceIface &input,
                                                                  QuickIfaceIface &iface0) = 0;
};

class SignalTestInterfaceIface;
typedef std::shared_ptr<SignalTestInterfaceIface> SignalTestInterfaceIfaceP;
typedef std::weak_ptr  <SignalTestInterfaceIface> SignalTestInterfaceIfaceW;

class SignalTestInterfaceIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              SignalTestInterfaceIface ();
  virtual  /*dtor*/                    ~SignalTestInterfaceIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
};

class ChildInheritingSignalsIface;
typedef std::shared_ptr<ChildInheritingSignalsIface> ChildInheritingSignalsIfaceP;
typedef std::weak_ptr  <ChildInheritingSignalsIface> ChildInheritingSignalsIfaceW;

class ChildInheritingSignalsIface : public virtual SignalTestInterfaceIface
{
protected:
  explicit                              ChildInheritingSignalsIface ();
  virtual  /*dtor*/                    ~ChildInheritingSignalsIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
};

class AnotherChildIface;
typedef std::shared_ptr<AnotherChildIface> AnotherChildIfaceP;
typedef std::weak_ptr  <AnotherChildIface> AnotherChildIfaceW;

class AnotherChildIface : public virtual SignalTestInterfaceIface
{
protected:
  explicit                              AnotherChildIface ();
  virtual  /*dtor*/                    ~AnotherChildIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
};

class PropertyTesterIface;
typedef std::shared_ptr<PropertyTesterIface> PropertyTesterIfaceP;
typedef std::weak_ptr  <PropertyTesterIface> PropertyTesterIfaceW;

class PropertyTesterIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              PropertyTesterIface ();
  virtual  /*dtor*/                    ~PropertyTesterIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual bool                          bool_prop      () const = 0;
  virtual void                          bool_prop      (bool) = 0;
  virtual int                           int32_prop     () const = 0;
  virtual void                          int32_prop     (int) = 0;
  virtual int64_t                       int64_prop     () const = 0;
  virtual void                          int64_prop     (int64_t) = 0;
  virtual double                        float64_prop   () const = 0;
  virtual void                          float64_prop   (double) = 0;
  virtual std::string                   string_prop    () const = 0;
  virtual void                          string_prop    (const std::string&) = 0;
  virtual QuickEnum                     enum_prop      () const = 0;
  virtual void                          enum_prop      (QuickEnum) = 0;
  virtual QuickRecord                   record_prop    () const = 0;
  virtual void                          record_prop    (const QuickRecord&) = 0;
  virtual QuickSequence                 sequence_prop  () const = 0;
  virtual void                          sequence_prop  (const QuickSequence&) = 0;
  virtual GrandChildIfaceP              interface_prop () const = 0;
  virtual void                          interface_prop (GrandChildIface*) = 0;
  virtual PropertyTesterIfaceP          self_prop      () const = 0;
  virtual void                          self_prop      (PropertyTesterIface*) = 0;
  virtual Aida::Any                     any_prop       () const = 0;
  virtual void                          any_prop       (const Aida::Any&) = 0;
};
} // InterfaceTests

namespace RapicornAidaTest {

class UseIncludesIface;
typedef std::shared_ptr<UseIncludesIface> UseIncludesIfaceP;
typedef std::weak_ptr  <UseIncludesIface> UseIncludesIfaceW;

class UseIncludesIface : public virtual IncludeCheck::SomeInterfaceIface
{
protected:
  explicit                              UseIncludesIface ();
  virtual  /*dtor*/                    ~UseIncludesIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
};

class ButtonAreaIface;
typedef std::shared_ptr<ButtonAreaIface> ButtonAreaIfaceP;
typedef std::weak_ptr  <ButtonAreaIface> ButtonAreaIfaceW;

class ButtonAreaIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              ButtonAreaIface ();
  virtual  /*dtor*/                    ~ButtonAreaIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual std::string                   on_click   () const = 0;
  virtual void                          on_click   (const std::string&) = 0;
  virtual std::string                   on_click2  () const = 0;
  virtual void                          on_click2  (const std::string&) = 0;
  virtual std::string                   on_click3  () const = 0;
  virtual void                          on_click3  (const std::string&) = 0;
  virtual ClickType                     click_type () const = 0;
  virtual void                          click_type (ClickType) = 0;
};

class PureMethodsIface;
typedef std::shared_ptr<PureMethodsIface> PureMethodsIfaceP;
typedef std::weak_ptr  <PureMethodsIface> PureMethodsIfaceW;


class PureMethodsIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              PureMethodsIface ();
  virtual  /*dtor*/                    ~PureMethodsIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual int                           pure_method      (double f) = 0;
};
} // RapicornAidaTest

namespace Other {

class NameTestsIface;
typedef std::shared_ptr<NameTestsIface> NameTestsIfaceP;
typedef std::weak_ptr  <NameTestsIface> NameTestsIfaceW;

class NameTestsIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              NameTestsIface ();
  virtual  /*dtor*/                    ~NameTestsIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual void                          args_from_other_namespace (const InterfaceTests::QuickRecord &qr,
                                                                   RapicornAidaTest::ClickType qe,
                                                                   const OtherNamespace::SomeRecord &sr) = 0;
};
} // Other

namespace BseTest {

class CompressorIface;
typedef std::shared_ptr<CompressorIface> CompressorIfaceP;
typedef std::weak_ptr  <CompressorIface> CompressorIfaceW;

class CompressorIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              CompressorIface ();
  virtual  /*dtor*/                    ~CompressorIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
  virtual double                        threshold () const = 0;
  virtual void                          threshold (double) = 0;
  virtual double                        ratio     () const = 0;
  virtual void                          ratio     (double) = 0;
};

class RecordForGroups
{
public:
  int                           i = 0;
  double                        ratio = 0;
  bool                          ordinary_bool = 0;
  double                        threshold1 = 0;
  double                        threshold2 = 0;
  inline                        RecordForGroups () = default;
  inline                        RecordForGroups (const Aida::AnyRec &r) { __visit__ ([&r] (auto &v, const char *n) { v = r[n].get< typename std::decay<decltype (v)>::type >(); }); }
  static const Aida::StringVector& __typedata__ ();
  bool                          operator==   (const RecordForGroups &other) const;
  bool                          operator!=   (const RecordForGroups &other) const { return !operator== (other); }
  operator                      Aida::AnyRec () const { Aida::AnyRec r; const_cast<RecordForGroups*> (this)->__visit__ ([&r] (const auto &v, const char *n) { r[n] = v; }); return r; }
  template<class Visitor> void  __visit__    (Visitor &&_visitor_);
};

class SoundModuleIface;
typedef std::shared_ptr<SoundModuleIface> SoundModuleIfaceP;
typedef std::weak_ptr  <SoundModuleIface> SoundModuleIfaceW;

class SoundModuleIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              SoundModuleIface ();
  virtual  /*dtor*/                    ~SoundModuleIface () override = 0;
public:
  virtual bool                          __access__         (const std::string &propertyname, const PropertyAccessorPred&) override;
};
} // BseTest

namespace MandatoryNamespace {
template<class Visitor> void
XFooRecord::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (single_bool, "single_bool");
  std::forward<Visitor> (_visitor_) (single_num, "single_num");
  std::forward<Visitor> (_visitor_) (num64, "num64");
  std::forward<Visitor> (_visitor_) (single_float, "single_float");
  std::forward<Visitor> (_visitor_) (single_string, "single_string");
  std::forward<Visitor> (_visitor_) (sibling1, "sibling1");
  std::forward<Visitor> (_visitor_) (sibling2, "sibling2");
  std::forward<Visitor> (_visitor_) (multi1, "multi1");
  std::forward<Visitor> (_visitor_) (multi2, "multi2");
  std::forward<Visitor> (_visitor_) (multi3, "multi3");
  std::forward<Visitor> (_visitor_) (multi4, "multi4");
  std::forward<Visitor> (_visitor_) (enum_field, "enum_field");
  std::forward<Visitor> (_visitor_) (iface1, "iface1");
  std::forward<Visitor> (_visitor_) (iface2, "iface2");
  std::forward<Visitor> (_visitor_) (iface3, "iface3");
  std::forward<Visitor> (_visitor_) (any1, "any1");
  std::forward<Visitor> (_visitor_) (any2, "any2");
  std::forward<Visitor> (_visitor_) (any3, "any3");
}
inline
XFooSequence::XFooSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<XFooSequence::value_type>::type >());
}
inline
XFooSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
IntSequence::IntSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<IntSequence::value_type>::type >());
}
inline
IntSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
FloatSequence::FloatSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<FloatSequence::value_type>::type >());
}
inline
FloatSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
StringSequence::StringSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<StringSequence::value_type>::type >());
}
inline
StringSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
ExtensiveEnumSequence::ExtensiveEnumSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<ExtensiveEnumSequence::value_type>::type >());
}
inline
ExtensiveEnumSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
RecordSequence::RecordSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<RecordSequence::value_type>::type >());
}
inline
RecordSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
SequenceSequence::SequenceSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<SequenceSequence::value_type>::type >());
}
inline
SequenceSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
InterfaceSequence::InterfaceSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<InterfaceSequence::value_type>::type >());
}
inline
InterfaceSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
inline
AnySequence::AnySequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<AnySequence::value_type>::type >());
}
template<class Visitor> void
NestedTypesRec::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (rec, "rec");
  std::forward<Visitor> (_visitor_) (seq, "seq");
}
inline
NestedTypesSeq::NestedTypesSeq (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<NestedTypesSeq::value_type>::type >());
}
inline
NestedTypesSeq::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
template<class Visitor> void
NewRecord::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (i, "i");
  std::forward<Visitor> (_visitor_) (enum1, "enum1");
  std::forward<Visitor> (_visitor_) (xfs, "xfs");
  std::forward<Visitor> (_visitor_) (ntr, "ntr");
}

namespace Inner {
template<class Visitor> void
InnerRecord::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (x, "x");
  std::forward<Visitor> (_visitor_) (y, "y");
  std::forward<Visitor> (_visitor_) (rec, "rec");
}
} // Inner
template<class Visitor> void
Refer2Inner::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (r, "r");
}
} // MandatoryNamespace

namespace OtherNamespace {
template<class Visitor> void
SomeRecord::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (r1, "r1");
  std::forward<Visitor> (_visitor_) (r2, "r2");
  std::forward<Visitor> (_visitor_) (r3, "r3");
  std::forward<Visitor> (_visitor_) (r4, "r4");
}
} // OtherNamespace

namespace Auxdata {
template<class Visitor> void
RecordWithAuxdata::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (aux_bool, "aux_bool");
  std::forward<Visitor> (_visitor_) (aux32, "aux32");
  std::forward<Visitor> (_visitor_) (aux64, "aux64");
  std::forward<Visitor> (_visitor_) (auxf64, "auxf64");
  std::forward<Visitor> (_visitor_) (aux_str, "aux_str");
}
} // Auxdata

namespace InterfaceTests {
template<class Visitor> void
QuickRecord::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (int1, "int1");
  std::forward<Visitor> (_visitor_) (int2, "int2");
}
inline
QuickSequence::QuickSequence (const Aida::AnySeq &s)
{
  for (const auto &any : s)
    push_back (any.get< typename std::decay<QuickSequence::value_type>::type >());
}
inline
QuickSequence::operator Aida::AnySeq () const
{
  Aida::AnySeq s;
  for (const auto &v : *this)
    s.push_back (Aida::Any (v));
  return s;
}
} // InterfaceTests

namespace BseTest {
template<class Visitor> void
RecordForGroups::__visit__ (Visitor &&_visitor_)
{
  std::forward<Visitor> (_visitor_) (i, "i");
  std::forward<Visitor> (_visitor_) (ratio, "ratio");
  std::forward<Visitor> (_visitor_) (ordinary_bool, "ordinary_bool");
  std::forward<Visitor> (_visitor_) (threshold1, "threshold1");
  std::forward<Visitor> (_visitor_) (threshold2, "threshold2");
}
} // BseTest

#define aidacc_tests_t304_testpass_idl_INTERFACE_LIST \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (MandatoryNamespace::FirstInterface) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::UIWidgetArea) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::Parent) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::Child) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::Descendant) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::GrandChild) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::QuickIface) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::MethodTestInterface) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::SignalTestInterface) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::ChildInheritingSignals) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::AnotherChild) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::PropertyTester) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (RapicornAidaTest::UseIncludes) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (RapicornAidaTest::ButtonArea) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (RapicornAidaTest::PureMethods) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (Other::NameTests) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (BseTest::Compressor) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (BseTest::SoundModule)
#define aidacc_tests_t304_testpass_idl_FOREACH_IFACE_SEQ() \
  aidacc_tests_t304_testpass_idl_FOREACH_STEP (MandatoryNamespace::InterfaceSequence) \


#else // DOXYGEN

namespace MandatoryNamespace {

/// IDL interface class for MandatoryNamespace::FirstInterface
/// @extends MandatoryNamespace::FirstInterface
class FirstInterfaceIface {};

/// @class MandatoryNamespace::FirstInterfaceImpl
/// @implements MandatoryNamespace::FirstInterface
} // MandatoryNamespace

namespace InterfaceTests {

/// IDL interface class for InterfaceTests::UIWidgetArea
/// @extends InterfaceTests::UIWidgetArea
class UIWidgetAreaIface {};

/// @class InterfaceTests::UIWidgetAreaImpl
/// @implements InterfaceTests::UIWidgetArea

/// IDL interface class for InterfaceTests::Parent
/// @extends InterfaceTests::Parent
class ParentIface {};

/// @class InterfaceTests::ParentImpl
/// @implements InterfaceTests::Parent

/// IDL interface class for InterfaceTests::Child
/// @extends InterfaceTests::Child
class ChildIface {};

/// @class InterfaceTests::ChildImpl
/// @implements InterfaceTests::Child

/// IDL interface class for InterfaceTests::Descendant
/// @extends InterfaceTests::Descendant
class DescendantIface {};

/// @class InterfaceTests::DescendantImpl
/// @implements InterfaceTests::Descendant

/// IDL interface class for InterfaceTests::GrandChild
/// @extends InterfaceTests::GrandChild
class GrandChildIface {};

/// @class InterfaceTests::GrandChildImpl
/// @implements InterfaceTests::GrandChild

/// IDL interface class for InterfaceTests::QuickIface
/// @extends InterfaceTests::QuickIface
class QuickIfaceIface {};

/// @class InterfaceTests::QuickIfaceImpl
/// @implements InterfaceTests::QuickIface

/// IDL interface class for InterfaceTests::MethodTestInterface
/// @extends InterfaceTests::MethodTestInterface
class MethodTestInterfaceIface {};

/// @class InterfaceTests::MethodTestInterfaceImpl
/// @implements InterfaceTests::MethodTestInterface

/// IDL interface class for InterfaceTests::SignalTestInterface
/// @extends InterfaceTests::SignalTestInterface
class SignalTestInterfaceIface {};

/// @class InterfaceTests::SignalTestInterfaceImpl
/// @implements InterfaceTests::SignalTestInterface

/// IDL interface class for InterfaceTests::ChildInheritingSignals
/// @extends InterfaceTests::ChildInheritingSignals
class ChildInheritingSignalsIface {};

/// @class InterfaceTests::ChildInheritingSignalsImpl
/// @implements InterfaceTests::ChildInheritingSignals

/// IDL interface class for InterfaceTests::AnotherChild
/// @extends InterfaceTests::AnotherChild
class AnotherChildIface {};

/// @class InterfaceTests::AnotherChildImpl
/// @implements InterfaceTests::AnotherChild

/// IDL interface class for InterfaceTests::PropertyTester
/// @extends InterfaceTests::PropertyTester
class PropertyTesterIface {};

/// @class InterfaceTests::PropertyTesterImpl
/// @implements InterfaceTests::PropertyTester
} // InterfaceTests

namespace RapicornAidaTest {

/// IDL interface class for RapicornAidaTest::UseIncludes
/// @extends RapicornAidaTest::UseIncludes
class UseIncludesIface {};

/// @class RapicornAidaTest::UseIncludesImpl
/// @implements RapicornAidaTest::UseIncludes

/// IDL interface class for RapicornAidaTest::ButtonArea
/// @extends RapicornAidaTest::ButtonArea
class ButtonAreaIface {};

/// @class RapicornAidaTest::ButtonAreaImpl
/// @implements RapicornAidaTest::ButtonArea

/// IDL interface class for RapicornAidaTest::PureMethods
/// @extends RapicornAidaTest::PureMethods
class PureMethodsIface {};

/// @class RapicornAidaTest::PureMethodsImpl
/// @implements RapicornAidaTest::PureMethods
} // RapicornAidaTest

namespace Other {

/// IDL interface class for Other::NameTests
/// @extends Other::NameTests
class NameTestsIface {};

/// @class Other::NameTestsImpl
/// @implements Other::NameTests
} // Other

namespace BseTest {

/// IDL interface class for BseTest::Compressor
/// @extends BseTest::Compressor
class CompressorIface {};

/// @class BseTest::CompressorImpl
/// @implements BseTest::Compressor

/// IDL interface class for BseTest::SoundModule
/// @extends BseTest::SoundModule
class SoundModuleIface {};

/// @class BseTest::SoundModuleImpl
/// @implements BseTest::SoundModule

} // BseTest
#endif // DOXYGEN

#endif /* __SRVT__aidacc_tests_t304_testpass_idl */
// --- Generated by AidaCxxStub ---
#include "t304-testpass_interfaces.hh"

#ifndef __AIDA_CXXSTUB_SERVER_CC__
#define __AIDA_CXXSTUB_SERVER_CC__

namespace { // Anon

namespace __AIDA_Local__ {
using namespace Aida;

static_assert (std::is_base_of<Aida::ImplicitBase, Aida::ImplicitBase>::value,
               "IDL interface base 'Aida::ImplicitBase' must derive 'Aida::ImplicitBase'");

// slot
template<class SharedPtr, class R, class... Args> std::function<R (Args...)>
slot (SharedPtr sp, R (*fp) (const SharedPtr&, Args...))
{
  return [sp, fp] (Args... args) { return fp (sp, args...); };
}

} } // Anon::__AIDA_Local__

#endif // __AIDA_CXXSTUB_SERVER_CC__


// --- Implementations ---

namespace MandatoryNamespace {

FirstInterfaceIface::FirstInterfaceIface ()
{}
FirstInterfaceIface::~FirstInterfaceIface ()
{} // define empty dtor to emit vtable
bool
FirstInterfaceIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_XFooRecord_ = {
  "typename=MandatoryNamespace.XFooRecord\0"
  "type=RECORD\0"
  "fields=single_bool;single_num;num64;single_float;single_string;sibling1;sibling2;multi1;multi2;multi3;multi4;enum_field;iface1;iface2;iface3;any1;any2;any3\0"
  "single_bool.type=BOOL\0"
  "single_num.type=INT32\0"
  "num64.type=INT64\0"
  "single_float.type=FLOAT64\0"
  "single_string.type=STRING\0"
  "sibling1.type=INT32\0"
  "sibling2.type=INT32\0"
  "multi1.type=INT32\0"
  "multi2.type=INT32\0"
  "multi3.type=INT32\0"
  "multi4.type=INT32\0"
  "enum_field.type=MandatoryNamespace.ExtensiveEnum\0"
  "iface1.type=MandatoryNamespace.FirstInterface\0"
  "iface2.type=MandatoryNamespace.FirstInterface\0"
  "iface3.type=MandatoryNamespace.FirstInterface\0"
  "any1.type=ANY\0"
  "any2.type=ANY\0"
  "any3.type=ANY\0"
};
const Aida::StringVector&
XFooRecord::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.XFooRecord");
  return sv;
}
bool
XFooRecord::operator== (const XFooRecord &other) const
{
  if (this->single_bool != other.single_bool) return false;
  if (this->single_num != other.single_num) return false;
  if (this->num64 != other.num64) return false;
  if (this->single_float != other.single_float) return false;
  if (this->single_string != other.single_string) return false;
  if (this->sibling1 != other.sibling1) return false;
  if (this->sibling2 != other.sibling2) return false;
  if (this->multi1 != other.multi1) return false;
  if (this->multi2 != other.multi2) return false;
  if (this->multi3 != other.multi3) return false;
  if (this->multi4 != other.multi4) return false;
  if (this->enum_field != other.enum_field) return false;
  if (this->iface1 != other.iface1) return false;
  if (this->iface2 != other.iface2) return false;
  if (this->iface3 != other.iface3) return false;
  if (this->any1 != other.any1) return false;
  if (this->any2 != other.any2) return false;
  if (this->any3 != other.any3) return false;
  return true;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_XFooSequence_ = {
  "typename=MandatoryNamespace.XFooSequence\0"
  "type=SEQUENCE\0"
  "fields=0\0"
  "0.type=BOOL\0"
};
const Aida::StringVector&
XFooSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.XFooSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_IntSequence_ = {
  "typename=MandatoryNamespace.IntSequence\0"
  "type=SEQUENCE\0"
  "fields=0\0"
  "0.type=INT32\0"
};
const Aida::StringVector&
IntSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.IntSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_FloatSequence_ = {
  "typename=MandatoryNamespace.FloatSequence\0"
  "type=SEQUENCE\0"
  "fields=0\0"
  "0.type=FLOAT64\0"
};
const Aida::StringVector&
FloatSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.FloatSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_StringSequence_ = {
  "typename=MandatoryNamespace.StringSequence\0"
  "type=SEQUENCE\0"
  "fields=0\0"
  "0.type=STRING\0"
};
const Aida::StringVector&
StringSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.StringSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_ExtensiveEnumSequence_ = {
  "typename=MandatoryNamespace.ExtensiveEnumSequence\0"
  "type=SEQUENCE\0"
  "fields=0\0"
  "0.type=MandatoryNamespace.ExtensiveEnum\0"
};
const Aida::StringVector&
ExtensiveEnumSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.ExtensiveEnumSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_RecordSequence_ = {
  "typename=MandatoryNamespace.RecordSequence\0"
  "type=SEQUENCE\0"
  "fields=0\0"
  "0.type=MandatoryNamespace.XFooRecord\0"
};
const Aida::StringVector&
RecordSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.RecordSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_SequenceSequence_ = {
  "typename=MandatoryNamespace.SequenceSequence\0"
  "type=SEQUENCE\0"
  "fields=0\0"
  "0.type=MandatoryNamespace.IntSequence\0"
};
const Aida::StringVector&
SequenceSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.SequenceSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_InterfaceSequence_ = {
  "typename=MandatoryNamespace.InterfaceSequence\0"
  "type=SEQUENCE\0"
  "fields=0\0"
  "0.type=MandatoryNamespace.FirstInterface\0"
};
const Aida::StringVector&
InterfaceSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.InterfaceSequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_AnySequence_ = {
  "typename=MandatoryNamespace.AnySequence\0"
  "type=SEQUENCE\0"
  "fields=0\0"
  "0.type=ANY\0"
};
const Aida::StringVector&
AnySequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.AnySequence");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_NestedTypesRec_ = {
  "typename=MandatoryNamespace.NestedTypesRec\0"
  "type=RECORD\0"
  "fields=rec;seq\0"
  "rec.type=MandatoryNamespace.XFooRecord\0"
  "seq.type=MandatoryNamespace.XFooSequence\0"
};
const Aida::StringVector&
NestedTypesRec::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.NestedTypesRec");
  return sv;
}
bool
NestedTypesRec::operator== (const NestedTypesRec &other) const
{
  if (this->rec != other.rec) return false;
  if (this->seq != other.seq) return false;
  return true;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_NestedTypesSeq_ = {
  "typename=MandatoryNamespace.NestedTypesSeq\0"
  "type=SEQUENCE\0"
  "fields=0\0"
  "0.type=MandatoryNamespace.NestedTypesRec\0"
};
const Aida::StringVector&
NestedTypesSeq::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.NestedTypesSeq");
  return sv;
}
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_NewRecord_ = {
  "typename=MandatoryNamespace.NewRecord\0"
  "type=RECORD\0"
  "fields=i;enum1;xfs;ntr\0"
  "i.type=INT32\0"
  "enum1.type=MandatoryNamespace.Enum1\0"
  "xfs.type=MandatoryNamespace.XFooSequence\0"
  "ntr.type=MandatoryNamespace.NestedTypesRec\0"
};
const Aida::StringVector&
NewRecord::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.NewRecord");
  return sv;
}
bool
NewRecord::operator== (const NewRecord &other) const
{
  if (this->i != other.i) return false;
  if (this->enum1 != other.enum1) return false;
  if (this->xfs != other.xfs) return false;
  if (this->ntr != other.ntr) return false;
  return true;
}

namespace Inner {
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Inner_InnerRecord_ = {
  "typename=MandatoryNamespace.Inner.InnerRecord\0"
  "type=RECORD\0"
  "fields=x;y;rec\0"
  "x.type=INT32\0"
  "y.type=INT32\0"
  "rec.type=MandatoryNamespace.NewRecord\0"
};
const Aida::StringVector&
InnerRecord::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.Inner.InnerRecord");
  return sv;
}
bool
InnerRecord::operator== (const InnerRecord &other) const
{
  if (this->x != other.x) return false;
  if (this->y != other.y) return false;
  if (this->rec != other.rec) return false;
  return true;
}
} // Inner
static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Refer2Inner_ = {
  "typename=MandatoryNamespace.Refer2Inner\0"
  "type=RECORD\0"
  "fields=r\0"
  "r.type=MandatoryNamespace.Inner.InnerRecord\0"
};
const Aida::StringVector&
Refer2Inner::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("MandatoryNamespace.Refer2Inner");
  return sv;
}
bool
Refer2Inner::operator== (const Refer2Inner &other) const
{
  if (this->r != other.r) return false;
  return true;
}
} // MandatoryNamespace

namespace OtherNamespace {
static const Aida::IntrospectionRegistry __aida__aux__data__OtherNamespace_SomeRecord_ = {
  "typename=OtherNamespace.SomeRecord\0"
  "type=RECORD\0"
  "fields=r1;r2;r3;r4\0"
  "r1.type=MandatoryNamespace.NewRecord\0"
  "r2.type=MandatoryNamespace.NewRecord\0"
  "r3.type=MandatoryNamespace.Inner.InnerRecord\0"
  "r4.type=MandatoryNamespace.Inner.InnerRecord\0"
};
const Aida::StringVector&
SomeRecord::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("OtherNamespace.SomeRecord");
  return sv;
}
bool
SomeRecord::operator== (const SomeRecord &other) const
{
  if (this->r1 != other.r1) return false;
  if (this->r2 != other.r2) return false;
  if (this->r3 != other.r3) return false;
  if (this->r4 != other.r4) return false;
  return true;
}
} // OtherNamespace

namespace Auxdata {
static const Aida::IntrospectionRegistry __aida__aux__data__Auxdata_RecordWithAuxdata_ = {
  "typename=Auxdata.RecordWithAuxdata\0"
  "type=RECORD\0"
  "fields=aux_bool;aux32;aux64;auxf64;aux_str\0"
  "aux_bool.type=BOOL\0"
  "aux_bool.label=AuxBool\0"
  "aux_bool.blurb=A Boolean\0"
  "aux_bool.hints=rw\0"
  "aux_bool.default=0\0"
  "aux32.type=INT32\0"
  "aux32.label=Aux32\0"
  "aux32.blurb=The Bar number\0"
  "aux32.hints=rw\0"
  "aux32.default=10007.0\0"
  "aux64.type=INT64\0"
  "aux64.label=Aux64\0"
  "aux64.blurb=64bit auxillary number\0"
  "aux64.hints=rw\0"
  "aux64.default=1152921504606846976\0"
  "auxf64.type=FLOAT64\0"
  "auxf64.label=AuxF64\0"
  "auxf64.blurb=X coordinate\0"
  "auxf64.hints=ro\0"
  "auxf64.default=0.019\0"
  "aux_str.type=STRING\0"
  "aux_str.label=AuxStr\0"
  "aux_str.blurb=Specify text here\0"
  "aux_str.hints=rw\0"
  "aux_str.default=auxtest3\0"
};
const Aida::StringVector&
RecordWithAuxdata::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("Auxdata.RecordWithAuxdata");
  return sv;
}
bool
RecordWithAuxdata::operator== (const RecordWithAuxdata &other) const
{
  if (this->aux_bool != other.aux_bool) return false;
  if (this->aux32 != other.aux32) return false;
  if (this->aux64 != other.aux64) return false;
  if (this->auxf64 != other.auxf64) return false;
  if (this->aux_str != other.aux_str) return false;
  return true;
}
} // Auxdata

namespace InterfaceTests {

UIWidgetAreaIface::UIWidgetAreaIface ()
{}
UIWidgetAreaIface::~UIWidgetAreaIface ()
{} // define empty dtor to emit vtable
bool
UIWidgetAreaIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  const bool __all = __n.empty();
  const char *const __aux__dummy =
    "type=BOOL\0";
  if ((__all || __n == "dummy") &&
      __p (Aida::PropertyAccessorImpl<UIWidgetAreaIface,bool> ("dummy", *this, &UIWidgetAreaIface::dummy, &UIWidgetAreaIface::dummy, __aux__dummy)))
    return true;
  const char *const __aux__on_click =
    "type=STRING\0"
    "label=On CLick\0"
    "blurb=Command on button1 click\0"
    "hints=rw\0";
  if ((__all || __n == "on_click") &&
      __p (Aida::PropertyAccessorImpl<UIWidgetAreaIface,std::string> ("on_click", *this, &UIWidgetAreaIface::on_click, &UIWidgetAreaIface::on_click, __aux__on_click)))
    return true;
  return false;
}

ParentIface::ParentIface ()
{}
ParentIface::~ParentIface ()
{} // define empty dtor to emit vtable
bool
ParentIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}

ChildIface::ChildIface ()
{}
ChildIface::~ChildIface ()
{} // define empty dtor to emit vtable
bool
ChildIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  if (this->ParentIface::__access__ (__n, __p)) return true;
  return false;
}

DescendantIface::DescendantIface ()
{}
DescendantIface::~DescendantIface ()
{} // define empty dtor to emit vtable
bool
DescendantIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  if (this->ChildIface::__access__ (__n, __p)) return true;
  return false;
}

GrandChildIface::GrandChildIface ()
{}
GrandChildIface::~GrandChildIface ()
{} // define empty dtor to emit vtable
bool
GrandChildIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  if (this->DescendantIface::__access__ (__n, __p)) return true;
  return false;
}
static const Aida::IntrospectionRegistry __aida__aux__data__InterfaceTests_QuickRecord_ = {
  "typename=InterfaceTests.QuickRecord\0"
  "type=RECORD\0"
  "fields=int1;int2\0"
  "int1.type=INT32\0"
  "int2.type=INT32\0"
};
const Aida::StringVector&
QuickRecord::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("InterfaceTests.QuickRecord");
  return sv;
}
bool
QuickRecord::operator== (const QuickRecord &other) const
{
  if (this->int1 != other.int1) return false;
  if (this->int2 != other.int2) return false;
  return true;
}
static const Aida::IntrospectionRegistry __aida__aux__data__InterfaceTests_QuickSequence_ = {
  "typename=InterfaceTests.QuickSequence\0"
  "type=SEQUENCE\0"
  "fields=0\0"
  "0.type=FLOAT64\0"
};
const Aida::StringVector&
QuickSequence::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("InterfaceTests.QuickSequence");
  return sv;
}

QuickIfaceIface::QuickIfaceIface ()
{}
QuickIfaceIface::~QuickIfaceIface ()
{} // define empty dtor to emit vtable
bool
QuickIfaceIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}

MethodTestInterfaceIface::MethodTestInterfaceIface ()
{}
MethodTestInterfaceIface::~MethodTestInterfaceIface ()
{} // define empty dtor to emit vtable
bool
MethodTestInterfaceIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}

SignalTestInterfaceIface::SignalTestInterfaceIface ()
{}
SignalTestInterfaceIface::~SignalTestInterfaceIface ()
{} // define empty dtor to emit vtable
bool
SignalTestInterfaceIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}

ChildInheritingSignalsIface::ChildInheritingSignalsIface ()
{}
ChildInheritingSignalsIface::~ChildInheritingSignalsIface ()
{} // define empty dtor to emit vtable
bool
ChildInheritingSignalsIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  if (this->SignalTestInterfaceIface::__access__ (__n, __p)) return true;
  return false;
}

AnotherChildIface::AnotherChildIface ()
{}
AnotherChildIface::~AnotherChildIface ()
{} // define empty dtor to emit vtable
bool
AnotherChildIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  if (this->SignalTestInterfaceIface::__access__ (__n, __p)) return true;
  return false;
}

PropertyTesterIface::PropertyTesterIface ()
{}
PropertyTesterIface::~PropertyTesterIface ()
{} // define empty dtor to emit vtable
bool
PropertyTesterIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  const bool __all = __n.empty();
  const char *const __aux__bool_prop =
    "type=BOOL\0";
  if ((__all || __n == "bool_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,bool> ("bool_prop", *this, &PropertyTesterIface::bool_prop, &PropertyTesterIface::bool_prop, __aux__bool_prop)))
    return true;
  const char *const __aux__int32_prop =
    "type=INT32\0";
  if ((__all || __n == "int32_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,int> ("int32_prop", *this, &PropertyTesterIface::int32_prop, &PropertyTesterIface::int32_prop, __aux__int32_prop)))
    return true;
  const char *const __aux__int64_prop =
    "type=INT64\0";
  if ((__all || __n == "int64_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,int64_t> ("int64_prop", *this, &PropertyTesterIface::int64_prop, &PropertyTesterIface::int64_prop, __aux__int64_prop)))
    return true;
  const char *const __aux__float64_prop =
    "type=FLOAT64\0";
  if ((__all || __n == "float64_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,double> ("float64_prop", *this, &PropertyTesterIface::float64_prop, &PropertyTesterIface::float64_prop, __aux__float64_prop)))
    return true;
  const char *const __aux__string_prop =
    "type=STRING\0";
  if ((__all || __n == "string_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,std::string> ("string_prop", *this, &PropertyTesterIface::string_prop, &PropertyTesterIface::string_prop, __aux__string_prop)))
    return true;
  const char *const __aux__enum_prop =
    "type=InterfaceTests.QuickEnum\0";
  if ((__all || __n == "enum_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,QuickEnum> ("enum_prop", *this, &PropertyTesterIface::enum_prop, &PropertyTesterIface::enum_prop, __aux__enum_prop)))
    return true;
  const char *const __aux__record_prop =
    "type=InterfaceTests.QuickRecord\0";
  if ((__all || __n == "record_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,QuickRecord> ("record_prop", *this, &PropertyTesterIface::record_prop, &PropertyTesterIface::record_prop, __aux__record_prop)))
    return true;
  const char *const __aux__sequence_prop =
    "type=InterfaceTests.QuickSequence\0";
  if ((__all || __n == "sequence_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,QuickSequence> ("sequence_prop", *this, &PropertyTesterIface::sequence_prop, &PropertyTesterIface::sequence_prop, __aux__sequence_prop)))
    return true;
  const char *const __aux__interface_prop =
    "type=InterfaceTests.GrandChild\0";
  if ((__all || __n == "interface_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,GrandChildIface> ("interface_prop", *this, &PropertyTesterIface::interface_prop, &PropertyTesterIface::interface_prop, __aux__interface_prop)))
    return true;
  const char *const __aux__self_prop =
    "type=InterfaceTests.PropertyTester\0";
  if ((__all || __n == "self_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,PropertyTesterIface> ("self_prop", *this, &PropertyTesterIface::self_prop, &PropertyTesterIface::self_prop, __aux__self_prop)))
    return true;
  const char *const __aux__any_prop =
    "type=ANY\0";
  if ((__all || __n == "any_prop") &&
      __p (Aida::PropertyAccessorImpl<PropertyTesterIface,Aida::Any> ("any_prop", *this, &PropertyTesterIface::any_prop, &PropertyTesterIface::any_prop, __aux__any_prop)))
    return true;
  return false;
}
} // InterfaceTests

namespace RapicornAidaTest {

UseIncludesIface::UseIncludesIface ()
{}
UseIncludesIface::~UseIncludesIface ()
{} // define empty dtor to emit vtable
bool
UseIncludesIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  if (this->IncludeCheck::SomeInterfaceIface::__access__ (__n, __p)) return true;
  return false;
}

ButtonAreaIface::ButtonAreaIface ()
{}
ButtonAreaIface::~ButtonAreaIface ()
{} // define empty dtor to emit vtable
bool
ButtonAreaIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  const bool __all = __n.empty();
  const char *const __aux__on_click =
    "type=STRING\0";
  if ((__all || __n == "on_click") &&
      __p (Aida::PropertyAccessorImpl<ButtonAreaIface,std::string> ("on_click", *this, &ButtonAreaIface::on_click, &ButtonAreaIface::on_click, __aux__on_click)))
    return true;
  const char *const __aux__on_click2 =
    "type=STRING\0";
  if ((__all || __n == "on_click2") &&
      __p (Aida::PropertyAccessorImpl<ButtonAreaIface,std::string> ("on_click2", *this, &ButtonAreaIface::on_click2, &ButtonAreaIface::on_click2, __aux__on_click2)))
    return true;
  const char *const __aux__on_click3 =
    "type=STRING\0";
  if ((__all || __n == "on_click3") &&
      __p (Aida::PropertyAccessorImpl<ButtonAreaIface,std::string> ("on_click3", *this, &ButtonAreaIface::on_click3, &ButtonAreaIface::on_click3, __aux__on_click3)))
    return true;
  const char *const __aux__click_type =
    "type=RapicornAidaTest.ClickType\0";
  if ((__all || __n == "click_type") &&
      __p (Aida::PropertyAccessorImpl<ButtonAreaIface,ClickType> ("click_type", *this, &ButtonAreaIface::click_type, &ButtonAreaIface::click_type, __aux__click_type)))
    return true;
  return false;
}

PureMethodsIface::PureMethodsIface ()
{}
PureMethodsIface::~PureMethodsIface ()
{} // define empty dtor to emit vtable
bool
PureMethodsIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}
} // RapicornAidaTest

namespace Other {

NameTestsIface::NameTestsIface ()
{}
NameTestsIface::~NameTestsIface ()
{} // define empty dtor to emit vtable
bool
NameTestsIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}
} // Other

namespace BseTest {

CompressorIface::CompressorIface ()
{}
CompressorIface::~CompressorIface ()
{} // define empty dtor to emit vtable
bool
CompressorIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  const bool __all = __n.empty();
  const char *const __aux__threshold =
    "type=FLOAT64\0"
    "hints=w\0"
    "default=0\0"
    "group=Compatibility Settings\0";
  if ((__all || __n == "threshold") &&
      __p (Aida::PropertyAccessorImpl<CompressorIface,double> ("threshold", *this, &CompressorIface::threshold, &CompressorIface::threshold, __aux__threshold)))
    return true;
  const char *const __aux__ratio =
    "type=FLOAT64\0"
    "hints=w\0"
    "default=0\0"
    "group=Compatibility Settings\0";
  if ((__all || __n == "ratio") &&
      __p (Aida::PropertyAccessorImpl<CompressorIface,double> ("ratio", *this, &CompressorIface::ratio, &CompressorIface::ratio, __aux__ratio)))
    return true;
  return false;
}
static const Aida::IntrospectionRegistry __aida__aux__data__BseTest_RecordForGroups_ = {
  "typename=BseTest.RecordForGroups\0"
  "type=RECORD\0"
  "fields=i;ratio;ordinary_bool;threshold1;threshold2\0"
  "i.type=INT32\0"
  "ratio.type=FLOAT64\0"
  "ratio.hints=w\0"
  "ratio.default=0\0"
  "ratio.group=Normal\0"
  "ordinary_bool.type=BOOL\0"
  "threshold1.type=FLOAT64\0"
  "threshold2.type=FLOAT64\0"
};
const Aida::StringVector&
RecordForGroups::__typedata__()
{
  static const Aida::StringVector &sv = Aida::Introspection::find_type ("BseTest.RecordForGroups");
  return sv;
}
bool
RecordForGroups::operator== (const RecordForGroups &other) const
{
  if (this->i != other.i) return false;
  if (this->ratio != other.ratio) return false;
  if (this->ordinary_bool != other.ordinary_bool) return false;
  if (this->threshold1 != other.threshold1) return false;
  if (this->threshold2 != other.threshold2) return false;
  return true;
}

SoundModuleIface::SoundModuleIface ()
{}
SoundModuleIface::~SoundModuleIface ()
{} // define empty dtor to emit vtable
bool
SoundModuleIface::__access__ (const std::string &__n, const PropertyAccessorPred &__p)
{
  return false;
}
} // BseTest


namespace Aida {

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum1_ = {
  "typename=MandatoryNamespace.Enum1\0"
  "type=ENUM\0"
  "enumerators=E1_A\0"
  "E1_A.value=1\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum1c_ = {
  "typename=MandatoryNamespace.Enum1c\0"
  "type=ENUM\0"
  "enumerators=E1C_A\0"
  "E1C_A.value=1\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum2_ = {
  "typename=MandatoryNamespace.Enum2\0"
  "type=ENUM\0"
  "enumerators=E2_A;E2_B\0"
  "E2_A.value=1\0"
  "E2_B.value=2\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum2c_ = {
  "typename=MandatoryNamespace.Enum2c\0"
  "type=ENUM\0"
  "enumerators=E2C_A;E2C_B\0"
  "E2C_A.value=1\0"
  "E2C_B.value=2\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum3_ = {
  "typename=MandatoryNamespace.Enum3\0"
  "type=ENUM\0"
  "enumerators=E3_A;E3_B;E3_C\0"
  "E3_A.value=1\0"
  "E3_B.value=2\0"
  "E3_C.value=3\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum3c_ = {
  "typename=MandatoryNamespace.Enum3c\0"
  "type=ENUM\0"
  "enumerators=E3C_A;E3C_B;E3C_C\0"
  "E3C_A.value=1\0"
  "E3C_B.value=2\0"
  "E3C_C.value=3\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum4a_ = {
  "typename=MandatoryNamespace.Enum4a\0"
  "type=ENUM\0"
  "enumerators=E4A_A;E4A_B;E4A_C;E4A_D\0"
  "E4A_A.value=1\0"
  "E4A_B.value=2\0"
  "E4A_C.value=3\0"
  "E4A_D.value=4\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum4b_ = {
  "typename=MandatoryNamespace.Enum4b\0"
  "type=ENUM\0"
  "enumerators=E4B_A;E4B_B;E4B_C;E4B_D\0"
  "E4B_A.value=1\0"
  "E4B_B.value=2\0"
  "E4B_C.value=3\0"
  "E4B_D.value=4\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum4c_ = {
  "typename=MandatoryNamespace.Enum4c\0"
  "type=ENUM\0"
  "enumerators=E4C_A;E4C_B;E4C_C;E4C_D\0"
  "E4C_A.value=1\0"
  "E4C_B.value=2\0"
  "E4C_C.value=3\0"
  "E4C_D.value=4\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_Enum4d_ = {
  "typename=MandatoryNamespace.Enum4d\0"
  "type=ENUM\0"
  "enumerators=E4D_A;E4D_B;E4D_C;E4D_D\0"
  "E4D_A.value=1\0"
  "E4D_B.value=2\0"
  "E4D_C.value=3\0"
  "E4D_D.value=4\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__MandatoryNamespace_ExtensiveEnum_ = {
  "typename=MandatoryNamespace.ExtensiveEnum\0"
  "type=ENUM\0"
  "enumerators=V1a;V1b;V2;V3;V4;V5;V6;V7;V8;V9;V10;V11;V12;V13;V14;V15;V16;V17;V18;V20;V21;V22;V23;V24;V25;V26;V27;V28;V30;V31;V32;V33;V34;V35;V36\0"
  "V1a.value=1\0"
  "V1b.value=1\0"
  "V2.value=2\0"
  "V3.value=3\0"
  "V3.label=" "v3" "\0"
  "V4.value=4\0"
  "V4.label=" _("v4") "\0"
  "V5.value=5\0"
  "V5.label=" "v5" "\0"
  "V5.blurb=" "V5" "\0"
  "V6.value=6\0"
  "V6.label=" _("v6") "\0"
  "V6.blurb=" "V6" "\0"
  "V7.value=7\0"
  "V7.label=" "v7" "\0"
  "V7.blurb=" _("V7") "\0"
  "V8.value=8\0"
  "V8.label=" _("v8") "\0"
  "V8.blurb=" _("V8") "\0"
  "V9.value=9\0"
  "V10.value=10\0"
  "V10.label=" "v10" "\0"
  "V11.value=11\0"
  "V11.label=" _("v11") "\0"
  "V12.value=12\0"
  "V12.label=" "v12" "\0"
  "V13.value=13\0"
  "V14.value=14\0"
  "V14.label=" _("v14") "\0"
  "V15.value=15\0"
  "V15.label=" "v15" "\0"
  "V15.blurb=" "V15" "\0"
  "V16.value=16\0"
  "V16.label=" _("v16") "\0"
  "V16.blurb=" "V16" "\0"
  "V17.value=17\0"
  "V17.label=" "v17" "\0"
  "V17.blurb=" _("V17") "\0"
  "V18.value=18\0"
  "V18.label=" _("v18") "\0"
  "V18.blurb=" _("V18") "\0"
  "V20.value=20\0"
  "V21.value=21\0"
  "V22.value=22\0"
  "V23.value=23\0"
  "V24.value=24\0"
  "V25.value=-9223372036854775808\0"
  "V26.value=9223372036854775807\0"
  "V27.value=9223372036854775807\0"
  "V28.value=-28\0"
  "V30.value=42\0"
  "V31.value=43\0"
  "V31.label=" "foo" "\0"
  "V32.value=42\0"
  "V33.value=43\0"
  "V33.label=" "foo" "\0"
  "V34.value=44\0"
  "V34.label=" "foo" "\0"
  "V34.blurb=" "foo" "\0"
  "V35.value=35\0"
  "V35.label=" "foo" "\0"
  "V36.value=42\0"
  "V36.label=" "foo" "\0"
  "V36.blurb=" "foo4" "\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__InterfaceTests_QuickEnum_ = {
  "typename=InterfaceTests.QuickEnum\0"
  "type=ENUM\0"
  "enumerators=ZERO\0"
  "ZERO.value=0\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__RapicornAidaTest_ClickType_ = {
  "typename=RapicornAidaTest.ClickType\0"
  "type=ENUM\0"
  "enumerators=CLICK_ON_PRESS;CLICK_ON_RELEASE;CLICK_SLOW_REPEAT;CLICK_FAST_REPEAT;CLICK_KEY_REPEAT\0"
  "CLICK_ON_PRESS.value=1\0"
  "CLICK_ON_RELEASE.value=2\0"
  "CLICK_SLOW_REPEAT.value=3\0"
  "CLICK_FAST_REPEAT.value=4\0"
  "CLICK_KEY_REPEAT.value=5\0"
};

static const Aida::IntrospectionRegistry __aida__aux__data__RapicornAidaTest_MathExpressions_ = {
  "typename=RapicornAidaTest.MathExpressions\0"
  "type=ENUM\0"
  "enumerators=RESULT_2;RESULT_5;RESULT_8;RESULT_6;RESULT_7;RESULT_16;RESULT_3;RESULT_24;RESULT_13;RESULT_m2;RESULT_77;RESULT_511\0"
  "RESULT_2.value=2\0"
  "RESULT_5.value=5\0"
  "RESULT_8.value=8\0"
  "RESULT_6.value=6\0"
  "RESULT_7.value=7\0"
  "RESULT_16.value=16\0"
  "RESULT_3.value=3\0"
  "RESULT_24.value=24\0"
  "RESULT_13.value=13\0"
  "RESULT_m2.value=-2\0"
  "RESULT_77.value=77\0"
  "RESULT_511.value=511\0"
};
} // Aida
