# Find required tools and packages
find_package(Perl REQUIRED)
find_package(PkgConfig REQUIRED)

# GLib (for glib-mkenums and other utilities)
find_package(GLIB2 REQUIRED COMPONENTS gio) # gio for glib-mkenums
include_directories(${GLIB2_INCLUDE_DIRS})
# GLIB_MKENUMS_EXECUTABLE is usually set by FindGLIB2.cmake

# Aidacc and SFIDL executables - these are expected to be targets from other subdirectories
# Ensure add_subdirectory(aidacc) and add_subdirectory(sfi) are called before bse/ in the root CMakeLists.txt
set(AIDACC_TARGET_NAME aidacc) # Assuming 'aidacc' is the executable target name from aidacc/CMakeLists.txt
set(SFIDL_TARGET_NAME sfidl)   # Assuming 'sfidl' is the executable target name from sfi/CMakeLists.txt

# --- System Configuration Checks ---

# Configure sysconfig-1.h (BSE_HAVE_TIMEGM)
include(CheckCSourceCompiles)
check_c_source_compiles("
#include <time.h>
void main() { struct tm t; timegm (&t); }
" HAVE_TIMEGM_INTERNAL)

set(SYSCONFIG_1_H_CONTENT "")
if(HAVE_TIMEGM_INTERNAL)
  set(SYSCONFIG_1_H_CONTENT "#define BSE_HAVE_TIMEGM 1")
else()
  set(SYSCONFIG_1_H_CONTENT "// #undef BSE_HAVE_TIMEGM")
endif()
file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/sysconfig-1.h "${SYSCONFIG_1_H_CONTENT}\n")

# Configure sysconfig-2.h (BSE_SPINLOCK_INITIALIZER)
# Original conftest_spinlock.c content:
set(CONTEST_SPINLOCK_C_CONTENT "
#include <stdio.h>
#include <string.h>
#include <pthread.h>
struct Spin { pthread_spinlock_t dummy1, s1, dummy2, s2, dummy3; };
int main (int argc, char *argv[]) {
  struct Spin spin;
  memset (&spin, 0xffffffff, sizeof (spin));
  if (pthread_spin_init (&spin.s1, 0) == 0 && pthread_spin_init (&spin.s2, 0) == 0 &&
      sizeof (pthread_spinlock_t) == 4 && spin.s1 == spin.s2)
    {
      FILE *f = fopen (\"conftest_spinlock.txt\", \"w\");
      fprintf (f, \"/*{*/ 0x%04x, /*}*/\\n\", *(int*) &spin.s1);
      fclose (f);
      return 0; // Success
    }
  return 1; // Failure
}")
file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/conftest_spinlock.c "${CONTEST_SPINLOCK_C_CONTENT}")

try_run(
  RUN_RESULT_VAR SPINLOCK_RUN_RESULT
  COMPILE_RESULT_VAR SPINLOCK_COMPILE_RESULT
  SOURCE_FILE ${CMAKE_CURRENT_BINARY_DIR}/conftest_spinlock.c
  COMPILE_DEFINITIONS "-Wall -pthread" # As per Makefile
  RUN_OUTPUT_VARIABLE SPINLOCK_RUN_OUTPUT # Not strictly needed for result, but good for debug
  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
  ARGS # No args for this test program
)

set(SYSCONFIG_2_H_CONTENT "// BSE_SPINLOCK_INITIALIZER not determined")
if(SPINLOCK_COMPILE_RESULT AND SPINLOCK_RUN_RESULT EQUAL 0)
  # Check if conftest_spinlock.txt was created and read it
  set(SPINLOCK_TXT_FILE ${CMAKE_CURRENT_BINARY_DIR}/conftest_spinlock.txt)
  if(EXISTS ${SPINLOCK_TXT_FILE})
    file(READ ${SPINLOCK_TXT_FILE} SPINLOCK_VALUE)
    string(STRIP "${SPINLOCK_VALUE}" SPINLOCK_VALUE_STRIPPED)
    set(SYSCONFIG_2_H_CONTENT "#define BSE_SPINLOCK_INITIALIZER ${SPINLOCK_VALUE_STRIPPED}")
  else()
    set(SYSCONFIG_2_H_CONTENT "// BSE_SPINLOCK_INITIALIZER: conftest_spinlock.txt not found after successful run")
  endif()
else()
  set(SYSCONFIG_2_H_CONTENT "// BSE_SPINLOCK_INITIALIZER: compilation or run failed (Compile: ${SPINLOCK_COMPILE_RESULT}, Run: ${SPINLOCK_RUN_RESULT})")
endif()
file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/sysconfig-2.h "${SYSCONFIG_2_H_CONTENT}\n")

# --- Generate sysconfig.h ---
set(SYSCONFIG_H_OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/sysconfig.h)
set(SYSCONFIG_H_IN ${CMAKE_CURRENT_SOURCE_DIR}/sysconfig.h.in) # We need to create this template

# Create sysconfig.h.in (if it doesn't exist, for the purpose of this generation)
# In a real scenario, this would be a file in the source tree.
file(WRITE ${SYSCONFIG_H_IN}
"// Generated by CMake
#define BSE_MAJOR_VERSION @BEAST_VERSION_MAJOR@
#define BSE_MINOR_VERSION @BEAST_VERSION_MINOR@
#define BSE_MICRO_VERSION @BEAST_VERSION_PATCH@
#define BSE_VERSION_STRING \"@BEAST_VERSION@\"
#define BSE_GETTEXT_DOMAIN \"beast\" // Assuming, needs verification from po/
// #define BSE_VORBISFILE_BAD_SEEK @VORBISFILE_BAD_SEEK@ // From Makefile, needs a check (e.g. pkg-config vorbisfile)

// Content from sysconfig-1.h
@SYSCONFIG_1_H_CONTENT@

// Content from sysconfig-2.h
@SYSCONFIG_2_H_CONTENT@
"
)

configure_file(
  ${SYSCONFIG_H_IN}
  ${SYSCONFIG_H_OUTPUT}
  @ONLY
)
# Note: BEAST_VERSION_MAJOR, MINOR, PATCH are available from project(... VERSION ...) in root CMakeLists.txt
# VORBISFILE_BAD_SEEK would require a check, e.g., using pkg-config for vorbisidec and checking a define.
# For now, it's commented out.

# --- Placeholder for External Dependencies (minizip, websocketpp) ---
# These would typically be handled by ExternalProject_Add or find_package if CMake modules are available

# ExternalProject_Add(minizip
#   PREFIX ${CMAKE_CURRENT_BINARY_DIR}/external/minizip_proj
#   URL https://github.com/nmoinvaz/minizip/archive/2.9.0.zip
#   URL_HASH SHA256=0c68fc9653203ca59a4b83598c89a86156c9142e08edbea9ae2430ee1e31babb
#   CONFIGURE_COMMAND "" # Header only or specific build steps if needed
#   BUILD_COMMAND ""
#   INSTALL_COMMAND ""
#   # OUTPUT_DIR for headers: ${CMAKE_CURRENT_BINARY_DIR}/external/minizip (to match makefile path)
# )
# set(MINIZIP_INCLUDE_DIR ${CMAKE_CURRENT_BINARY_DIR}/external/minizip) # Path to mz_zip.h after download/extract
# add_custom_target(minizip_target DEPENDS ...) # To trigger download

# ExternalProject_Add(websocketpp
#   PREFIX ${CMAKE_CURRENT_BINARY_DIR}/external/websocketpp_proj
#   URL https://github.com/zaphoyd/websocketpp/archive/0.8.2.tar.gz
#   URL_HASH SHA256=6ce889d85ecdc2d8fa07408d6787e7352510750daa66b5ad44aacb47bea76755
#   CONFIGURE_COMMAND ""
#   BUILD_COMMAND ""
#   INSTALL_COMMAND ""
# )
# set(WEBSOCKETPP_INCLUDE_DIR ${CMAKE_CURRENT_BINARY_DIR}/external/websocketpp) # Path to server.hpp
# add_custom_target(websocketpp_target DEPENDS ...)

# Include directories for these would be added to targets requiring them.
# For now, these are just conceptual placeholders. The makefile downloads them directly.
# We can use FetchContent for a more integrated CMake approach as well.

# --- Generated sources (examples, more to come) ---

# $>/bse/bseapi_interfaces.hh, $>/bse/bseapi_interfaces.cc from bse/bseapi.idl
set(BSEAPI_IDL_INPUT ${CMAKE_CURRENT_SOURCE_DIR}/bseapi.idl)
set(BSEAPI_INSERTS ${CMAKE_CURRENT_SOURCE_DIR}/bseapi-inserts.inc.hh)
set(BSEAPI_INTERFACES_HH ${CMAKE_CURRENT_BINARY_DIR}/bseapi_interfaces.hh)
set(BSEAPI_INTERFACES_CC ${CMAKE_CURRENT_BINARY_DIR}/bseapi_interfaces.cc)

add_custom_command(
  OUTPUT ${BSEAPI_INTERFACES_HH} ${BSEAPI_INTERFACES_CC}
  COMMAND ${AIDACC_TARGET_NAME} # Use target name directly
    -x CxxStub
    -G strip-path=${CMAKE_CURRENT_SOURCE_DIR}/ # To match $(abspath .)/
    --insertions ${BSEAPI_INSERTS}
    -o ${CMAKE_CURRENT_BINARY_DIR} # Output directory
    ${BSEAPI_IDL_INPUT}
  COMMAND sed -i '1i#define _(x) x' ${BSEAPI_INTERFACES_CC} # Note: direct sed might not be portable
  COMMAND sed -i '1i#undef _' ${BSEAPI_INTERFACES_CC}     # Consider string(REPLACE) or a helper script
  DEPENDS ${BSEAPI_IDL_INPUT} ${BSEAPI_INSERTS} ${AIDACC_TARGET_NAME}
  COMMENT "Generating CxxStub interfaces from ${BSEAPI_IDL_INPUT}"
  VERBATIM
)
# The sed command here is problematic for portability.
# A CMake approach would be to configure a template file or use string operations.
# For now, leaving as sed to match Makefile, but this is a known issue.

# $>/bse/bseapi_jsonipc.cc from bse/bseapi.idl using JsonipcStub.py
set(BSEAPI_JSONIPC_CC ${CMAKE_CURRENT_BINARY_DIR}/bseapi_jsonipc.cc)
add_custom_command(
  OUTPUT ${BSEAPI_JSONIPC_CC}
  COMMAND ${AIDACC_TARGET_NAME} # Use target name directly
    -x ${CMAKE_SOURCE_DIR}/../aidacc/JsonipcStub.py # Path to JsonipcStub.py
    ${BSEAPI_IDL_INPUT}
    -o ${BSEAPI_JSONIPC_CC}.tmp
    -G nblocks=4
    -G strip-path=${CMAKE_CURRENT_BINARY_DIR}/ # To match $(abspath $>)/
  COMMAND ${CMAKE_COMMAND} -E copy_if_different ${BSEAPI_JSONIPC_CC}.tmp ${BSEAPI_JSONIPC_CC}
  COMMAND ${CMAKE_COMMAND} -E remove ${BSEAPI_JSONIPC_CC}.tmp
  # The original makefile also does `chmod -w` on the output, which is unusual.
  DEPENDS ${BSEAPI_IDL_INPUT} ${AIDACC_TARGET_NAME} ${CMAKE_SOURCE_DIR}/../aidacc/JsonipcStub.py
  COMMENT "Generating JSON-IPC C++ stubs from ${BSEAPI_IDL_INPUT}"
  VERBATIM
)

# $>/bse/bse_jsonipc_stub[1-4].cc
set(BSE_JSONIPC_STUB_SOURCES "")
foreach(num IN RANGE 1 4)
  set(STUB_OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/bse_jsonipc_stub${num}.cc)
  set(STUB_GENERATOR_SCRIPT ${CMAKE_CURRENT_BINARY_DIR}/generate_bse_jsonipc_stub${num}.cmake)

  # Create a CMake script that will write the content of the stub file
  file(WRITE ${STUB_GENERATOR_SCRIPT}
"
set(STUB_FILE_OUTPUT \\\"${STUB_OUTPUT}\\\")
set(STUB_CONTENT
\\\"#include \\\\\\\"bse/beast-sound-engine.hh\\\\\\\"
#define BLOCK_TYPES ${num}
#include \\\\\\\"bseapi_jsonipc.cc\\\\\\\"
void bse_jsonipc_stub${num} () { Bse_jsonipc_stub(); }
\\\")
file(WRITE \${STUB_FILE_OUTPUT} \\\"\${STUB_CONTENT}\\\")
"
  )
  add_custom_command(
    OUTPUT ${STUB_OUTPUT}
    COMMAND ${CMAKE_COMMAND} -P ${STUB_GENERATOR_SCRIPT}
    DEPENDS ${BSEAPI_JSONIPC_CC} # Main dependency is the included .cc file
    MAIN_DEPENDENCY ${STUB_GENERATOR_SCRIPT} # Script itself is a dependency
    COMMENT "Generating ${STUB_OUTPUT}"
    VERBATIM
  )
  list(APPEND BSE_JSONIPC_STUB_SOURCES ${STUB_OUTPUT})
endforeach()

# --- GLIB_MKENUMS generated files ---
# Based on Makefile: $(filter bse/bse%, $(bse/libbse.headers))
# This implies scanning all headers in bse/ starting with bse.
file(GLOB BSE_ONLY_HEADERS_SCAN LIST_DIRECTORIES false "${CMAKE_CURRENT_SOURCE_DIR}/bse*.hh")
# Ensure this list is accurate for GObject enums/flags.
# Example: message(STATUS "Headers for glib-mkenums: ${BSE_ONLY_HEADERS_SCAN}")

# $>/bse/bseenum_arrays.cc
set(BSEENUM_ARRAYS_OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/bseenum_arrays.cc)
add_custom_command(
  OUTPUT ${BSEENUM_ARRAYS_OUTPUT}
  COMMAND ${GLIB_MKENUMS_EXECUTABLE}
    --fprod "\n/* --- @filename@ --- */\n#include\t\"@filename@\""
    --vhead "/* @EnumName@\n */\nstatic G@Type@Value @enum_name@_values[] = { // enum_values\n"
    --vprod "  { @VALUENAME@, \\\"@VALUENAME@\\\", \\\"@valuenick@\\\" },"
    --vtail "  { 0, NULL, NULL }\n};\n"
    ${BSE_ONLY_HEADERS_SCAN} > ${BSEENUM_ARRAYS_OUTPUT}.tmp
  COMMAND ${CMAKE_COMMAND} -E copy_if_different ${BSEENUM_ARRAYS_OUTPUT}.tmp ${BSEENUM_ARRAYS_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E remove ${BSEENUM_ARRAYS_OUTPUT}.tmp
  DEPENDS ${BSE_ONLY_HEADERS_SCAN}
  MAIN_DEPENDENCY ${GLIB_MKENUMS_EXECUTABLE}
  COMMENT "Generating GObject enum arrays: ${BSEENUM_ARRAYS_OUTPUT}"
  VERBATIM
)

# $>/bse/bseenum_list.cc
set(BSEENUM_LIST_OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/bseenum_list.cc)
add_custom_command(
  OUTPUT ${BSEENUM_LIST_OUTPUT}
  COMMAND ${GLIB_MKENUMS_EXECUTABLE}
    --fprod "\n/* --- @filename@ --- */"
    --eprod "  { \\\"@EnumName@\\\", G_TYPE_@TYPE@, &BSE_TYPE_ID (@EnumName@), @enum_name@_values },"
    ${BSE_ONLY_HEADERS_SCAN} > ${BSEENUM_LIST_OUTPUT}.tmp
  COMMAND ${CMAKE_COMMAND} -E copy_if_different ${BSEENUM_LIST_OUTPUT}.tmp ${BSEENUM_LIST_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E remove ${BSEENUM_LIST_OUTPUT}.tmp
  DEPENDS ${BSE_ONLY_HEADERS_SCAN} ${BSEENUM_ARRAYS_OUTPUT} # Depends on _values defined in arrays
  MAIN_DEPENDENCY ${GLIB_MKENUMS_EXECUTABLE}
  COMMENT "Generating GObject enum list: ${BSEENUM_LIST_OUTPUT}"
  VERBATIM
)

# --- SFIDL and Perl generated files ---
set(BSEBASICS_IDL ${CMAKE_CURRENT_SOURCE_DIR}/bsebasics.idl)
set(BSEBUSMODULE_IDL ${CMAKE_CURRENT_SOURCE_DIR}/bsebusmodule.idl)
set(MKTYPES_PL ${CMAKE_CURRENT_SOURCE_DIR}/mktypes.pl)

# Collect all .cc and .c sources from bse/ for mktypes.pl
file(GLOB BSE_ALL_SOURCES_FOR_MKTYPES
  "${CMAKE_CURRENT_SOURCE_DIR}/*.c"
  "${CMAKE_CURRENT_SOURCE_DIR}/*.cc"
)
# TODO: Exclude specific files as per bse/libbse.exclude in Makefile if necessary for mktypes.pl

# $>/bse/bsegentypes.h
set(BSEGENTYPES_H_OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/bsegentypes.h)
set(SFIDL_INCLUDES_ARGS ) # Populate this if sfidl needs -I flags, e.g. from sfi/sfidl.includes
# Example: list(APPEND SFIDL_INCLUDES_ARGS -I${CMAKE_SOURCE_DIR}/../sfi)

add_custom_command(
  OUTPUT ${BSEGENTYPES_H_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E touch ${BSEGENTYPES_H_OUTPUT}.tmp # Start with an empty temp file
  COMMAND ${GLIB_MKENUMS_EXECUTABLE}
    --fprod "\n/* --- @filename@ --- */"
    --eprod "#define BSE_TYPE_@ENUMSHORT@\t (BSE_TYPE_ID (@EnumName@)) // enum\nextern GType BSE_TYPE_ID (@EnumName@);"
    ${BSE_ONLY_HEADERS_SCAN} >> ${BSEGENTYPES_H_OUTPUT}.tmp
  COMMAND ${PERL_EXECUTABLE} ${MKTYPES_PL} --externs ${BSE_ALL_SOURCES_FOR_MKTYPES} >> ${BSEGENTYPES_H_OUTPUT}.tmp
  COMMAND ${SFIDL_TARGET_NAME} ${SFIDL_INCLUDES_ARGS} --core-c --header ${BSEBASICS_IDL} >> ${BSEGENTYPES_H_OUTPUT}.tmp
  COMMAND ${CMAKE_COMMAND} -E copy_if_different ${BSEGENTYPES_H_OUTPUT}.tmp ${BSEGENTYPES_H_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E remove ${BSEGENTYPES_H_OUTPUT}.tmp
  DEPENDS ${BSE_ONLY_HEADERS_SCAN} ${MKTYPES_PL} ${BSE_ALL_SOURCES_FOR_MKTYPES} ${SFIDL_TARGET_NAME} ${BSEBASICS_IDL} ${GLIB_MKENUMS_EXECUTABLE}
  COMMENT "Generating bsegentypes.h"
  VERBATIM
)

# $>/bse/bsegentypes.cc
set(BSEGENTYPES_CC_OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/bsegentypes.cc)
add_custom_command(
  OUTPUT ${BSEGENTYPES_CC_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E touch ${BSEGENTYPES_CC_OUTPUT}.tmp
  COMMAND ${GLIB_MKENUMS_EXECUTABLE}
    --eprod "\nGType BSE_TYPE_ID (@EnumName@) = 0;"
    ${BSE_ONLY_HEADERS_SCAN} >> ${BSEGENTYPES_CC_OUTPUT}.tmp
  COMMAND ${PERL_EXECUTABLE} ${MKTYPES_PL} --interns --export-proto ${BSE_ALL_SOURCES_FOR_MKTYPES} >> ${BSEGENTYPES_CC_OUTPUT}.tmp
  COMMAND ${CMAKE_COMMAND} -E copy_if_different ${BSEGENTYPES_CC_OUTPUT}.tmp ${BSEGENTYPES_CC_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E remove ${BSEGENTYPES_CC_OUTPUT}.tmp
  DEPENDS ${BSE_ONLY_HEADERS_SCAN} ${MKTYPES_PL} ${BSE_ALL_SOURCES_FOR_MKTYPES} ${GLIB_MKENUMS_EXECUTABLE}
  COMMENT "Generating bsegentypes.cc"
  VERBATIM
)

# $>/bse/bsegentype_array.cc
set(BSEGENTYPE_ARRAY_CC_OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/bsegentype_array.cc)
add_custom_command(
  OUTPUT ${BSEGENTYPE_ARRAY_CC_OUTPUT}
  COMMAND ${PERL_EXECUTABLE} ${MKTYPES_PL} --array ${BSE_ALL_SOURCES_FOR_MKTYPES} > ${BSEGENTYPE_ARRAY_CC_OUTPUT}.tmp
  COMMAND ${CMAKE_COMMAND} -E copy_if_different ${BSEGENTYPE_ARRAY_CC_OUTPUT}.tmp ${BSEGENTYPE_ARRAY_CC_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E remove ${BSEGENTYPE_ARRAY_CC_OUTPUT}.tmp
  DEPENDS ${MKTYPES_PL} ${BSE_ALL_SOURCES_FOR_MKTYPES}
  COMMENT "Generating bsegentype_array.cc"
  VERBATIM
)

# $>/bse/bsegenbasics.cc
set(BSEGENBASICS_CC_OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/bsegenbasics.cc)
add_custom_command(
  OUTPUT ${BSEGENBASICS_CC_OUTPUT}
  COMMAND ${SFIDL_TARGET_NAME} ${SFIDL_INCLUDES_ARGS}
    --core-c --source --init sfidl_types_init ${BSEBASICS_IDL} > ${BSEGENBASICS_CC_OUTPUT}.tmp
  COMMAND ${CMAKE_COMMAND} -E copy_if_different ${BSEGENBASICS_CC_OUTPUT}.tmp ${BSEGENBASICS_CC_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E remove ${BSEGENBASICS_CC_OUTPUT}.tmp
  DEPENDS ${SFIDL_TARGET_NAME} ${BSEBASICS_IDL}
  COMMENT "Generating bsegenbasics.cc"
  VERBATIM
)

# $>/bse/bsebasics.genidl.hh
set(BSEBASICS_GENIDL_HH_OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/bsebasics.genidl.hh)
get_filename_component(BSEBASICS_IDL_FILENAME ${BSEBASICS_IDL} NAME)
add_custom_command(
  OUTPUT ${BSEBASICS_GENIDL_HH_OUTPUT}
  COMMAND ${SFIDL_TARGET_NAME} ${SFIDL_INCLUDES_ARGS}
    --core-cxx --macro ${BSEBASICS_IDL_FILENAME} ${BSEBASICS_IDL} > ${BSEBASICS_GENIDL_HH_OUTPUT}.tmp
  COMMAND ${CMAKE_COMMAND} -E copy_if_different ${BSEBASICS_GENIDL_HH_OUTPUT}.tmp ${BSEBASICS_GENIDL_HH_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E remove ${BSEBASICS_GENIDL_HH_OUTPUT}.tmp
  DEPENDS ${SFIDL_TARGET_NAME} ${BSEBASICS_IDL}
  COMMENT "Generating bsebasics.genidl.hh"
  VERBATIM
)

# $>/bse/bsebusmodule.genidl.hh
set(BSEBUSMODULE_GENIDL_HH_OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/bsebusmodule.genidl.hh)
get_filename_component(BSEBUSMODULE_IDL_FILENAME ${BSEBUSMODULE_IDL} NAME)
add_custom_command(
  OUTPUT ${BSEBUSMODULE_GENIDL_HH_OUTPUT}
  COMMAND ${SFIDL_TARGET_NAME} ${SFIDL_INCLUDES_ARGS}
    --core-cxx --macro ${BSEBUSMODULE_IDL_FILENAME} ${BSEBUSMODULE_IDL} > ${BSEBUSMODULE_GENIDL_HH_OUTPUT}.tmp
  COMMAND ${CMAKE_COMMAND} -E copy_if_different ${BSEBUSMODULE_GENIDL_HH_OUTPUT}.tmp ${BSEBUSMODULE_GENIDL_HH_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E remove ${BSEBUSMODULE_GENIDL_HH_OUTPUT}.tmp
  DEPENDS ${SFIDL_TARGET_NAME} ${BSEBUSMODULE_IDL}
  COMMENT "Generating bsebusmodule.genidl.hh"
  VERBATIM
)

# List of all generated source files for BSE
set(BSE_GENERATED_SOURCES
  ${BSEAPI_INTERFACES_CC}
  ${BSEAPI_JSONIPC_CC}
  ${BSE_JSONIPC_STUB_SOURCES} # This is already a list
  ${BSEENUM_ARRAYS_OUTPUT}
  ${BSEENUM_LIST_OUTPUT}
  # BSEGENTYPES_H_OUTPUT is a header, object files will depend on it via include structure normally
  ${BSEGENTYPES_CC_OUTPUT}
  ${BSEGENTYPE_ARRAY_CC_OUTPUT}
  ${BSEGENBASICS_CC_OUTPUT}
  # Still need: gslfft.cc, zres.cc
  # Added below
)
set(BSE_GENERATED_HEADERS # Headers that other files might include and should be ready
  ${SYSCONFIG_H_OUTPUT} # Generated header
  ${BSEAPI_INTERFACES_HH}
  ${BSEBASICS_GENIDL_HH_OUTPUT}
  ${BSEBUSMODULE_GENIDL_HH_OUTPUT}
  ${BSEGENTYPES_H_OUTPUT} # Generated header
  # Other generated headers if any
)

# Target to ensure all generated files are built
add_custom_target(bse_generated_files ALL
  DEPENDS
    ${BSE_GENERATED_SOURCES}
    ${BSE_GENERATED_HEADERS} # Custom commands for headers ensure they are built too
)


# TODO:
# - Source lists for libbse (core), libbsejack (optional), BeastSoundEngine executable
# - gslfft.cc generation - ADDED
# - zres.cc generation - ADDED
# - Define actual library (libbse, libbsejack) and executable (BeastSoundEngine) targets
# - Linker script bse/ldscript.map usage
# - Installation rules for all headers, libs, executables
# - Handle dependencies (BSEDEPS_CFLAGS, ALSA_LIBS, JACK_LIBS, BOOST_SYSTEM_LIBS etc.) using PkgConfig or FindXXX modules
# - Proper handling of ExternalProject_Add or FetchContent for minizip (partial - ADDED) and websocketpp

message(STATUS "BSE CMakeLists.txt: Added gslfft, zres, FetchContent for minizip, and more package finding.")
message(STATUS "  SFIDL includes will need to be configured (e.g. -I flags for sfidl tool).")
message(STATUS "  AIDACC_TARGET_NAME: ${AIDACC_TARGET_NAME}")
message(STATUS "  SFIDL_TARGET_NAME: ${SFIDL_TARGET_NAME}")
message(STATUS "  GLIB_MKENUMS_EXECUTABLE: ${GLIB_MKENUMS_EXECUTABLE}")
message(STATUS "  SYSCONFIG_H_OUTPUT: ${SYSCONFIG_H_OUTPUT}")
# message(STATUS "  BSEAPI_INTERFACES_HH: ${BSEAPI_INTERFACES_HH}") # Now in BSE_GENERATED_HEADERS
# message(STATUS "  BSEAPI_JSONIPC_CC: ${BSEAPI_JSONIPC_CC}")   # Now in BSE_GENERATED_SOURCES

# Add include directories for generated files and source files
include_directories(SYSTEM ${CMAKE_CURRENT_BINARY_DIR}) # Generated headers
include_directories(${CMAKE_CURRENT_SOURCE_DIR})     # Source headers in bse/

# --- Collect Source Files ---
# LIBBSE_SOURCES
file(GLOB BSE_ALL_C_FILES RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "${CMAKE_CURRENT_SOURCE_DIR}/*.c")
file(GLOB BSE_ALL_CC_FILES RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "${CMAKE_CURRENT_SOURCE_DIR}/*.cc")

set(LIBBSE_EXCLUDE_SOURCES
  "beast-sound-engine.cc" # From bse/BeastSoundEngine.sources
  "jsonipcstubs.cc"       # From bse/BeastSoundEngine.sources
  "driver-jack.cc"        # From bse/libbsejack.sources
)

set(LIBBSE_SOURCES "")
foreach(src_file IN LISTS BSE_ALL_C_FILES BSE_ALL_CC_FILES)
  if(NOT src_file MATCHES "\\.inc\\.c$" AND NOT src_file MATCHES "\\.inc\\.cc$")
    list(FIND LIBBSE_EXCLUDE_SOURCES ${src_file} IS_EXCLUDED)
    if(IS_EXCLUDED EQUAL -1)
      list(APPEND LIBBSE_SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/${src_file})
    endif()
  endif()
endforeach()
list(APPEND LIBBSE_SOURCES ${BSE_GENERATED_SOURCES}) # Add all generated C/CC sources

# LIBBSE_HEADERS
file(GLOB BSE_ALL_HH_FILES RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "${CMAKE_CURRENT_SOURCE_DIR}/*.hh")
set(LIBBSE_EXCLUDE_HEADERS
  "beast-sound-engine.hh" # From bse/BeastSoundEngine.headers
)
set(LIBBSE_HEADERS "")
foreach(hdr_file IN LISTS BSE_ALL_HH_FILES)
  if(NOT hdr_file MATCHES "\\.inc\\.hh$")
    list(FIND LIBBSE_EXCLUDE_HEADERS ${hdr_file} IS_EXCLUDED)
    if(IS_EXCLUDED EQUAL -1)
      list(APPEND LIBBSE_HEADERS ${CMAKE_CURRENT_SOURCE_DIR}/${hdr_file})
    endif()
  endif()
endforeach()
list(APPEND LIBBSE_HEADERS ${BSE_GENERATED_HEADERS}) # Add all generated .h/.hh files

# LIBBSEJACK_SOURCES
set(LIBBSEJACK_SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/driver-jack.cc)

# BEASTSOUNDENGINE_SOURCES
set(BEASTSOUNDENGINE_SOURCES
  ${CMAKE_CURRENT_SOURCE_DIR}/beast-sound-engine.cc
  ${CMAKE_CURRENT_SOURCE_DIR}/jsonipcstubs.cc
  ${BSE_JSONIPC_STUB_SOURCES} # These are already full paths
)

# --- Find Package Dependencies ---
find_package(Boost REQUIRED COMPONENTS system) # For BOOST_SYSTEM_LIBS
find_package(Threads REQUIRED) # For pthread
find_package(ALSA REQUIRED) # For ALSA_LIBS
pkg_check_modules(GDK_PIXBUF REQUIRED gdk-pixbuf-2.0) # For gdk-pixbuf-csource and linking if needed
find_program(GDK_PIXBUF_CSOURCE_EXECUTABLE NAMES gdk-pixbuf-csource gdk-pixbuf-csource-2.0 REQUIRED)

# BSEDEPS_PACKAGES from config-checks.mk: fluidsynth vorbisenc vorbisfile vorbis ogg flac zlib $(GLIB_PACKAGES)
pkg_check_modules(FLUIDSYNTH REQUIRED fluidsynth>=2.0.5)
pkg_check_modules(VORBISENC REQUIRED vorbisenc>=1.3.2) # includes vorbis
pkg_check_modules(VORBISFILE REQUIRED vorbisfile>=1.3.2) # includes vorbis
pkg_check_modules(OGG REQUIRED ogg>=1.2.2)
pkg_check_modules(FLAC REQUIRED flac>=1.2.1)
pkg_check_modules(ZLIB REQUIRED zlib) # Often pulled by others, but explicit is fine

option(ENABLE_MAD "Enable MAD MP3 decoding support" ON) # Makefile implies MAD is optional/conditional
if(ENABLE_MAD)
  pkg_check_modules(MAD mad>=0.14.2)
  if(MAD_FOUND)
    message(STATUS "MAD support enabled. Found MAD version: ${MAD_VERSION}")
  else()
    message(WARNING "ENABLE_MAD is ON but libmad not found. Disabling MAD support for BSE.")
    set(ENABLE_MAD OFF) # Update option if not found
  endif()
endif()

option(ENABLE_JACK "Enable JACK Audio Support" ON)
if(ENABLE_JACK)
  find_package(PkgConfig REQUIRED)
  pkg_check_modules(JACK REQUIRED jack)
  if(JACK_FOUND)
    message(STATUS "JACK support enabled. Found JACK version: ${JACK_VERSION}")
    include_directories(SYSTEM ${JACK_INCLUDE_DIRS})
    # JACK_LIBRARIES will be used in target_link_libraries
  else()
    message(WARNING "ENABLE_JACK is ON but JACK library not found. Disabling JACK support.")
    set(ENABLE_JACK OFF)
  endif()
endif()

# --- FetchContent for External Libraries ---
include(FetchContent)

# Minizip (Used for unzipping, possibly for handling .bse files if they are zips)
# Makefile fetches 2.9.0. The version here might need adjustment if API changed.
FetchContent_Declare(
  minizip
  GIT_REPOSITORY https://github.com/nmoinvaz/minizip.git
  GIT_TAG 2.9.0 # Corresponds to the version in Makefile
)
FetchContent_GetProperties(minizip)
if(NOT minizip_POPULATED)
  FetchContent_Populate(minizip)
  # Add specific targets or include directories if minizip builds as a library.
  # If it's header-only or we compile sources directly:
  # For version 2.9.0, it seems it's not strictly header-only.
  # It has .c files like mz_zip.c, mz_strm.c etc.
  # The makefile just ensures mz_zip.h is available.
  # For CMake, we might need to build it as a library or add its sources.
  # For now, let's assume we just need the headers available.
  include_directories(SYSTEM ${minizip_SOURCE_DIR})
  # A better way would be to have minizip provide an actual CMake target if its CMakeLists.txt supports it,
  # or create an INTERFACE library target for it.
  # For now, direct include_directories.
  # The makefile rule for $(bse/libbse.objects): $>/external/minizip/mz_zip.h
  # This implies mz_zip.h from the specified path is used.
  # We need to ensure our include path for minizip matches this expectation if source files include "mz_zip.h" directly.
  # The source directory of FetchContent (minizip_SOURCE_DIR) will contain mz_zip.h.
  message(STATUS "minizip source dir: ${minizip_SOURCE_DIR}")
endif()
# Minizip C sources to compile into libbse (as per typical usage, since Makefile doesn't make it a separate lib)
if(minizip_POPULATED)
  # These are common minizip C files. Adjust if version 2.9.0 has different ones.
  # From looking at minizip 2.9.0, it has mz_crypt.*, mz_os.*, mz_strm.*, mz_zip.*, mz_compat.*
  # We need to be selective based on what Beast actually uses or link all core .c files.
  # The makefile only shows dependency on mz_zip.h for compilation of bse objects.
  # This implies either headers are enough ( unlikely for .zip ) or .c files are included elsewhere.
  # Let's assume for now no separate minizip lib is built by make, so its sources are part of bse.
  # This is a common way to bundle small C libraries.
  # However, modern FetchContent often expects the dependency to build itself.
  # For now, no minizip sources added directly to libbse; will rely on include_directories.
  # If linking errors occur, this is where to look.
  # A better approach for minizip would be:
  # FetchContent_MakeAvailable(minizip)
  # This would use minizip's own CMakeLists.txt if it has one that defines a library target.
  # Minizip 2.9.0 does have a CMakeLists.txt. Let's try that.
  FetchContent_MakeAvailable(minizip) # This will configure and build minizip if it has a CMakeLists.txt
                                      # It should define a target like 'minizip' or 'minizipstatic'.
  # We will need to link libbse against the target minizip provides.
  # This is deferred to target_link_libraries.
  message(STATUS "minizip should be available via FetchContent_MakeAvailable. Target: minizip or similar.")
else()
  message(WARNING "minizip not populated by FetchContent. Check GIT_REPOSITORY and GIT_TAG.")
endif()

# WebsocketPP (For remote control / UI communication)
FetchContent_Declare(
  websocketpp
  GIT_REPOSITORY https://github.com/zaphoyd/websocketpp.git
  GIT_TAG 0.8.2
)
FetchContent_GetProperties(websocketpp)
if(NOT websocketpp_POPULATED)
  FetchContent_Populate(websocketpp)
  # WebsocketPP is header-only, so we just need its include directory.
  # It requires Boost.Asio or standalone Asio. We are linking Boost::system, ensure Asio is covered.
  # Boost find_package should make Boost::asio available if it's part of the system Boost.
  include_directories(SYSTEM ${websocketpp_SOURCE_DIR}) # Add websocketpp source for includes
  message(STATUS "websocketpp source dir: ${websocketpp_SOURCE_DIR}")
endif()
# TODO: Ensure Asio dependency for WebsocketPP is handled (either standalone or via Boost).

# --- Icon C Source Generation (from bse/icons/Makefile.mk) ---
set(BSE_ICON_PNG_FILES
  biquad.png
  const.png
  instrument.png
  keyboard.png
  mic.png
  midi-ctrl-input.png
  mono-synth.png
  osc.png
  speaker.png
  virtual-input.png
  virtual-output.png
  virtual-synth.png
  waveosc.png
)

set(BSE_ICON_GENERATED_SOURCES "")
set(BSE_ICONS_OUTPUT_DIR ${CMAKE_CURRENT_BINARY_DIR}/icons)
file(MAKE_DIRECTORY ${BSE_ICONS_OUTPUT_DIR})

foreach(icon_png_basename IN LISTS BSE_ICON_PNG_FILES)
  set(icon_png_full_path ${CMAKE_CURRENT_SOURCE_DIR}/icons/${icon_png_basename})
  string(REPLACE "-" "_" c_name_base ${icon_png_basename})
  string(REPLACE "." "_" c_name_base ${c_name_base}) # e.g. biquad_png
  set(c_identifier "${c_name_base}_pixstream") # e.g. biquad_png_pixstream
  set(generated_c_file ${BSE_ICONS_OUTPUT_DIR}/${c_name_base}.c)

  add_custom_command(
    OUTPUT ${generated_c_file}
    COMMAND ${GDK_PIXBUF_CSOURCE_EXECUTABLE} --name=${c_identifier} ${icon_png_full_path} > ${generated_c_file}.tmp
    COMMAND ${CMAKE_COMMAND} -E copy_if_different ${generated_c_file}.tmp ${generated_c_file}
    COMMAND ${CMAKE_COMMAND} -E remove ${generated_c_file}.tmp
    DEPENDS ${icon_png_full_path} ${GDK_PIXBUF_CSOURCE_EXECUTABLE}
    COMMENT "Generating C source from icon: ${icon_png_basename}"
    VERBATIM
  )
  list(APPEND BSE_ICON_GENERATED_SOURCES ${generated_c_file})
endforeach()
list(APPEND LIBBSE_SOURCES ${BSE_ICON_GENERATED_SOURCES})
include_directories(SYSTEM ${GDK_PIXBUF_INCLUDE_DIRS}) # For generated icon code to find GdkPixbuf types

# --- gslfft.cc generation ---
# Requires: bse/gsl-fftconf.sh, bse/gsl-fftgen.pl
set(GSLFFT_CC_OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/gslfft.cc)
set(GSL_FFTCONF_SH ${CMAKE_CURRENT_SOURCE_DIR}/gsl-fftconf.sh)
set(GSL_FFTGEN_PL ${CMAKE_CURRENT_SOURCE_DIR}/gsl-fftgen.pl)
set(GSLFFT_HH_FOR_SCRIPT "bse/gslfft.hh") # Path as expected by gsl-fftgen.pl

# The makefile command:
# bse/gsl-fftconf.sh '$(PERL) bse/gsl-fftgen.pl $(if $(findstring 1, $V),, --no-verbose)' '"bse/gslfft.hh"' > $@.tmp
# $V seems to be a verbosity flag. Assuming not verbose for CMake.
set(PERL_SCRIPT_CMD "${PERL_EXECUTABLE} ${GSL_FFTGEN_PL} --no-verbose")

add_custom_command(
  OUTPUT ${GSLFFT_CC_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env bash ${GSL_FFTCONF_SH} "${PERL_SCRIPT_CMD}" "${GSLFFT_HH_FOR_SCRIPT}" > ${GSLFFT_CC_OUTPUT}.tmp
  COMMAND ${CMAKE_COMMAND} -E copy_if_different ${GSLFFT_CC_OUTPUT}.tmp ${GSLFFT_CC_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E remove ${GSLFFT_CC_OUTPUT}.tmp
  DEPENDS ${GSL_FFTCONF_SH} ${GSL_FFTGEN_PL} # And potentially bse/gslfft.hh if it's an input to the script
  COMMENT "Generating gslfft.cc using gsl-fftconf.sh and gsl-fftgen.pl"
  VERBATIM
)
list(APPEND BSE_GENERATED_SOURCES ${GSLFFT_CC_OUTPUT})

# --- zres.cc generation ---
# Requires: res/resfiles.list, misc/packres.py
set(ZRES_CC_OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/zres.cc)
set(PACKRES_PY ${CMAKE_SOURCE_DIR}/../misc/packres.py) # Path to packres.py from root
set(RESFILES_LIST_PATH ${CMAKE_SOURCE_DIR}/../res/resfiles.list) # Path to resfiles.list from root

# Read res/resfiles.list content
file(STRINGS ${RESFILES_LIST_PATH} RESFILES_CONTENT_LIST)
set(RESFILES_ARGS "")
foreach(res_file IN LISTS RESFILES_CONTENT_LIST)
  if(res_file) # Ensure not an empty line
    # Paths in resfiles.list are like "bse/adsr-wave-1.bse"
    # The makefile command prepends "res/" to each: $(res_resfiles_list:%=res/%)
    # So "res/bse/adsr-wave-1.bse"
    list(APPEND RESFILES_ARGS "res/${res_file}")
  endif()
endforeach()

# The makefile command: misc/packres.py -z -s 'res/' $(res_resfiles_list:%=res/%)
# Run packres.py from the project root directory (../ from CMAKE_CURRENT_BINARY_DIR for bse)
# Or, adjust paths if running from CMAKE_CURRENT_BINARY_DIR.
# Let's assume packres.py is best run from project root.
# CMAKE_SOURCE_DIR is the root of the project.
add_custom_command(
  OUTPUT ${ZRES_CC_OUTPUT}
  COMMAND ${Python3_EXECUTABLE} ${PACKRES_PY} -z -s "res/" ${RESFILES_ARGS} > ${ZRES_CC_OUTPUT}.tmp
  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR} # Run from project root
  COMMAND ${CMAKE_COMMAND} -E copy_if_different "${ZRES_CC_OUTPUT}.tmp" "${ZRES_CC_OUTPUT}" # Need to specify full path for tmp if WORKDIR changed
  COMMAND ${CMAKE_COMMAND} -E remove "${CMAKE_SOURCE_DIR}/${ZRES_CC_OUTPUT}.tmp" # remove from where it was created
  DEPENDS ${PACKRES_PY} ${RESFILES_LIST_PATH} # And all files listed in resfiles.list
  COMMENT "Generating zres.cc using packres.py"
  VERBATIM
)
# This is tricky due to WORKING_DIRECTORY. A safer way:
# 1. Configure a script that CD to root, runs python, then copies output back to CMAKE_CURRENT_BINARY_DIR
# Or ensure packres.py can handle output path argument.
# For now, this assumes packres.py output to stdout is captured.
# The copy/remove will need to handle paths carefully.
# Let's simplify: run packres.py and direct output to the final location, assuming it's in CMAKE_CURRENT_BINARY_DIR
# This means packres.py needs to be callable from CMAKE_CURRENT_BINARY_DIR and understand paths relative to CMAKE_SOURCE_DIR

# Re-think zres.cc generation path handling:
# Paths in RESFILES_ARGS are now "res/bse/file.bse".
# If packres.py is run from CMAKE_SOURCE_DIR (project root), these paths are correct.
# Output should be ${CMAKE_CURRENT_BINARY_DIR}/zres.cc
add_custom_command(
  OUTPUT ${ZRES_CC_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env --working-directory ${CMAKE_SOURCE_DIR} ${Python3_EXECUTABLE} ${PACKRES_PY} -z -s "res/" ${RESFILES_ARGS} > ${ZRES_CC_OUTPUT}
  DEPENDS ${PACKRES_PY} ${RESFILES_LIST_PATH} # And all files listed in resfiles.list
  COMMENT "Generating zres.cc using packres.py from project root"
  VERBATIM
)
# The above uses 'env --working-directory', which is good.
# Output redirection `> ${ZRES_CC_OUTPUT}` will write to a path relative to CMAKE_CURRENT_BINARY_DIR if not absolute.
# ${ZRES_CC_OUTPUT} is already an absolute path. This should work.
list(APPEND BSE_GENERATED_SOURCES ${ZRES_CC_OUTPUT})


# Placeholder for actual library and executable definitions

add_library(bse SHARED
  ${LIBBSE_SOURCES}
  $<TARGET_OBJECTS:bse_devices_objlib> # Add object files from devices/
)
target_compile_definitions(bse PRIVATE BSE_COMPILATION)
# Apply compile options from Makefile: EXTRA_FLAGS ::= -Wno-sign-promo
target_compile_options(bse PRIVATE -Wno-sign-promo)

target_include_directories(bse PUBLIC
  $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}> # For generated headers like sysconfig.h, bseapi_interfaces.hh
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}> # For bse's own source headers
  $<INSTALL_INTERFACE:include/bse> # For installed headers
)
target_include_directories(bse INTERFACE
  ${CMAKE_SOURCE_DIR}/external/pugixml/src   # For pugixml headers
  ${CMAKE_SOURCE_DIR}/external/rapidjson/include # For rapidjson headers
  ${CMAKE_SOURCE_DIR}/jsonipc                # For jsonipc.hh
)

# Add minizip include directory if FetchContent_MakeAvailable didn't make it a transitive property of a minizip target
# This is typically handled by minizip::minizip target if it's well-defined by FetchContent_MakeAvailable.
# if(minizip_POPULATED AND NOT TARGET minizip::minizip) # Heuristic check if a target was made
#   target_include_directories(bse INTERFACE ${minizip_SOURCE_DIR})
# endif()
# Add websocketpp include directory
if(websocketpp_POPULATED)
  target_include_directories(bse INTERFACE ${websocketpp_SOURCE_DIR}) # For headers from websocketpp
endif()

# Set VERSION and SOVERSION properties for bse
set_target_properties(bse PROPERTIES
  VERSION ${BEAST_VERSION}
  SOVERSION ${BEAST_VERSION_MAJOR}
)

# Apply linker script for bse
set(BSE_LINKER_SCRIPT ${CMAKE_CURRENT_SOURCE_DIR}/ldscript.map)
if(EXISTS ${BSE_LINKER_SCRIPT})
  # For GNU linker (ld)
  set_property(TARGET bse APPEND_STRING PROPERTY LINK_FLAGS " -Wl,--version-script=${BSE_LINKER_SCRIPT}")
  # For Apple linker (ld64) - different syntax if needed, but Beast is Linux-focused.
else()
  message(WARNING "Linker script not found: ${BSE_LINKER_SCRIPT}")
endif()

# Link bse library
target_link_libraries(bse PRIVATE
  ${GLIB2_LIBRARIES}      # From find_package(GLIB2) -> GLIB_PACKAGES
  ${GDK_PIXBUF_LIBRARIES} # From pkg_check_modules(GDK_PIXBUF)
  Boost::system           # From find_package(Boost)
  Threads::Threads        # From find_package(Threads)
  ALSA::ALSA              # From find_package(ALSA)
  ${FLUIDSYNTH_LIBRARIES}
  ${VORBISENC_LIBRARIES}  # Includes vorbis
  ${VORBISFILE_LIBRARIES} # Includes vorbis
  ${OGG_LIBRARIES}
  ${FLAC_LIBRARIES}
  ${ZLIB_LIBRARIES}
  stdc++fs                # For C++17 filesystem, as seen in Makefile
)
if(ENABLE_MAD AND MAD_FOUND)
  target_link_libraries(bse PRIVATE ${MAD_LIBRARIES})
endif()

# Link minizip if FetchContent_MakeAvailable defined a target (e.g., minizip::minizip or minizipstatic)
if(TARGET minizip::minizip)
  target_link_libraries(bse PRIVATE minizip::minizip)
elseif(TARGET minizip) # Some projects might define just 'minizip'
  target_link_libraries(bse PRIVATE minizip)
elseif(TARGET minizipstatic) # Some might define minizipstatic for a static lib
  target_link_libraries(bse PRIVATE minizipstatic)
else()
  message(WARNING "minizip target not found after FetchContent_MakeAvailable. Manual linking or source addition might be needed if libbse uses minizip symbols.")
endif()
# TODO: Identify and link other BSEDEPS_LIBS from Makefile if any (this should cover most now).

# --- libbsejack ---
if(ENABLE_JACK AND JACK_FOUND)
  add_library(bsejack SHARED ${LIBBSEJACK_SOURCES})
  set_target_properties(bsejack PROPERTIES
    VERSION ${BEAST_VERSION}
    SOVERSION ${BEAST_VERSION_MAJOR}
  )
  if(EXISTS ${BSE_LINKER_SCRIPT})
    set_property(TARGET bsejack APPEND_STRING PROPERTY LINK_FLAGS " -Wl,--version-script=${BSE_LINKER_SCRIPT}")
  endif()
  target_link_libraries(bsejack PRIVATE bse ${JACK_LIBRARIES})
  target_compile_definitions(bsejack PRIVATE BSE_COMPILATION) # From Makefile for bsejack objects
  # Include directories for bsejack (it needs bse's public headers and generated headers)
  target_include_directories(bsejack PRIVATE
    $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}> # For sysconfig.h etc.
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
  )
endif()

# --- BeastSoundEngine executable ---
add_executable(BeastSoundEngine ${BEASTSOUNDENGINE_SOURCES})
target_link_libraries(BeastSoundEngine PRIVATE
  bse
  Boost::system # Explicitly, as per Makefile for BeastSoundEngine program
  # Link against BSEDEPS_LIBS directly as well, as per Makefile logic
  # (BeastSoundEngine ... $(lib/libbse.so) ... -lbse-$(VERSION_MAJOR) $(BOOST_SYSTEM_LIBS) $(BSEDEPS_LIBS))
  # This suggests bse might not export all symbols from BSEDEPS_LIBS or BeastSoundEngine uses them directly.
  ${FLUIDSYNTH_LIBRARIES}
  ${VORBISENC_LIBRARIES}
  ${VORBISFILE_LIBRARIES}
  ${OGG_LIBRARIES}
  ${FLAC_LIBRARIES}
  ${ZLIB_LIBRARIES}
  # GLIB2_LIBRARIES are needed if BeastSoundEngine uses GLib directly,
  # otherwise they are linked via bse if bse exports them.
  # For safety, if makefile lists them for the exe, add them.
  ${GLIB2_LIBRARIES}
)
if(ENABLE_MAD AND MAD_FOUND)
  target_link_libraries(BeastSoundEngine PRIVATE ${MAD_LIBRARIES})
endif()

# Compile flags from Makefile for BeastSoundEngine.objects: -Wno-sign-promo (already on bse)
# EXTRA_INCLUDES for BeastSoundEngine.objects: -Iexternal/ -I$> -I$>/external/ $(GLIB_CFLAGS)
# -I$> is CMAKE_CURRENT_BINARY_DIR, -I$>/external/ is for websocketpp/minizip if manually included
# GLIB_CFLAGS are already part of bse linkage / includes.
# If websocketpp or minizip are header-only and fetched via FetchContent, their include dirs are handled via bse's INTERFACE_INCLUDE_DIRECTORIES.
# If BeastSoundEngine directly includes headers from external/ that bse does not, add them here.
if(websocketpp_POPULATED) # Assuming BeastSoundEngine might use websocketpp directly
    target_include_directories(BeastSoundEngine PRIVATE ${websocketpp_SOURCE_DIR})
endif()
if(minizip_POPULATED AND NOT TARGET minizip::minizip) # If minizip headers are needed directly and no target exposes them
    target_include_directories(BeastSoundEngine PRIVATE ${minizip_SOURCE_DIR})
endif()


# --- Installation Rules ---
set(BSE_INSTALL_INCLUDE_DIR include/bse) # Relative to CMAKE_INSTALL_PREFIX
set(BSE_INSTALL_LIB_DIR ${CMAKE_INSTALL_LIBDIR}) # Standard lib dir
set(BSE_INSTALL_BIN_DIR ${CMAKE_INSTALL_BINDIR}) # Standard bin dir
set(BSE_PKG_LIB_DIR ${CMAKE_INSTALL_LIBDIR}/${PROJECT_NAME}) # For private executables like BeastSoundEngine as per Makefile

# Install libbse
install(TARGETS bse
  LIBRARY DESTINATION ${BSE_INSTALL_LIB_DIR}
  ARCHIVE DESTINATION ${BSE_INSTALL_LIB_DIR} # For static import lib on Windows if ever relevant
  RUNTIME DESTINATION ${BSE_INSTALL_BIN_DIR} # For DLL on Windows if ever relevant
)

# Install libbsejack
if(ENABLE_JACK AND JACK_FOUND AND TARGET bsejack)
  install(TARGETS bsejack
    LIBRARY DESTINATION ${BSE_INSTALL_LIB_DIR}
    ARCHIVE DESTINATION ${BSE_INSTALL_LIB_DIR}
    RUNTIME DESTINATION ${BSE_INSTALL_BIN_DIR}
  )
endif()

# Install BeastSoundEngine executable
install(TARGETS BeastSoundEngine
  RUNTIME DESTINATION ${BSE_PKG_LIB_DIR} # Makefile: $(DESTDIR)$(pkglibdir)/lib
)

# Install Headers
# From Makefile: $(bse/include.headers) $(bse/libbse.deps))
# $(bse/include.headers) was LIBBSE_HEADERS + generated .idl.hh + libbse.deps
# LIBBSE_HEADERS already contains most source .hh files and core generated .h/.hh like sysconfig.h
# bse/libbse.deps in makefile: bseapi_interfaces.hh, bsebasics.genidl.hh, bsebusmodule.genidl.hh, bsegentypes.h, sysconfig.h
# These are already in LIBBSE_HEADERS if generated, or should be.
install(FILES ${LIBBSE_HEADERS}
  DESTINATION ${BSE_INSTALL_INCLUDE_DIR}
)

# Install IDL files (Makefile puts them in include dir)
set(BSE_IDL_FILES_TO_INSTALL
  ${CMAKE_CURRENT_SOURCE_DIR}/bsebasics.idl
  ${CMAKE_CURRENT_SOURCE_DIR}/bsebusmodule.idl
  ${CMAKE_CURRENT_SOURCE_DIR}/bsecxxbase.idl
  ${CMAKE_CURRENT_SOURCE_DIR}/bsecxxmodule.idl
  ${CMAKE_CURRENT_SOURCE_DIR}/bseapi.idl # bseapi.idl also seems to be a primary IDL
)
install(FILES ${BSE_IDL_FILES_TO_INSTALL}
  DESTINATION ${BSE_INSTALL_INCLUDE_DIR}
)

# TODO: Check installation paths, especially for BeastSoundEngine (bin vs libexec/prj)
# TODO: Identify and install any other headers or resource files.
# TODO: What are BSEDEPS_LIBS/CFLAGS? (Now mostly handled by pkg-config)
# TODO: Check if any specific BSEDEPS_CFLAGS are needed beyond include dirs from pkg-config.
#       The Makefile uses $(BSEDEPS_CFLAGS) for compiling bse objects.
#       pkg_check_modules provides _CFLAGS which are typically include directories.
#       If there are other compile definitions or flags in original BSEDEPS_CFLAGS, they need adding.
#       For now, assuming include directories are primary.
#       We can add these CFLAGS to 'bse' and 'BeastSoundEngine' if needed.
#       target_compile_options(bse PRIVATE ${FLUIDSYNTH_CFLAGS_OTHER} ...)

# Further steps will refine installation and handle any remaining Makefile items like sfidl includes.
